"""
Task Manager MCP Module - —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∞–º–∏ —á–µ—Ä–µ–∑ MCP –∫–æ–º–∞–Ω–¥—ã.

–ò–Ω—Ç–µ–≥—Ä–∏—Ä—É–µ—Ç—Å—è —Å duck.todo.md –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏–∑–∞—Ü–∏–∏ workflow —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∞–º–∏.
"""

import sys
import json
import time
import re
from pathlib import Path
from typing import Dict, List, Any, Optional
from datetime import datetime

# –î–æ–±–∞–≤–ª—è–µ–º –ø—É—Ç—å –∫ —Å–∏—Å—Ç–µ–º–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–æ–≤
sys.path.append(str(Path(__file__).parent.parent.parent))

try:
    from mcp.python_backends.standards_integration import StandardsIntegration
    STANDARDS_AVAILABLE = True
except ImportError:
    STANDARDS_AVAILABLE = False

class TaskManager:
    """MCP –º–æ–¥—É–ª—å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∞–º–∏"""
    
    def __init__(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è task manager"""
        self.todo_file = Path("[todo ¬∑ incidents]/duck.todo.md")
        self.standards_integration = None
        
        if STANDARDS_AVAILABLE:
            try:
                self.standards_integration = StandardsIntegration()
            except Exception as e:
                print(f"Standards integration unavailable: {e}")
    
    def get_next_task(self) -> Dict[str, Any]:
        """
        MCP –∫–æ–º–∞–Ω–¥–∞: next-task
        –ü–æ–ª—É—á–∞–µ—Ç —Å–ª–µ–¥—É—é—â—É—é –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—É—é –∑–∞–¥–∞—á—É –∏–∑ —Å–ø–∏—Å–∫–∞.
        """
        start_time = time.time()
        
        result = {
            "command": "next-task",
            "success": False,
            "next_task": None,
            "task_number": None,
            "subtasks": [],
            "context": ""
        }
        
        try:
            if not self.todo_file.exists():
                result["error"] = f"Todo file not found: {self.todo_file}"
                return result
            
            with open(self.todo_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # –ò—â–µ–º –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏
            tasks = self._parse_incomplete_tasks(content)
            
            if tasks:
                next_task = tasks[0]  # –ë–µ—Ä–µ–º –ø–µ—Ä–≤—É—é –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—É—é
                result.update({
                    "success": True,
                    "next_task": next_task["title"],
                    "task_number": next_task["number"],
                    "subtasks": next_task["subtasks"],
                    "context": f"–ù–∞–π–¥–µ–Ω–æ {len(tasks)} –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã—Ö –∑–∞–¥–∞—á"
                })
            else:
                result.update({
                    "success": True,
                    "context": "–í—Å–µ –∑–∞–¥–∞—á–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã! üéâ"
                })
                
        except Exception as e:
            result["error"] = str(e)
        
        result["duration_ms"] = (time.time() - start_time) * 1000
        return result
    
    def complete_task(self, task_number: int, completion_note: str = "") -> Dict[str, Any]:
        """
        MCP –∫–æ–º–∞–Ω–¥–∞: complete-task
        –û—Ç–º–µ—á–∞–µ—Ç –∑–∞–¥–∞—á—É –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—É—é.
        """
        start_time = time.time()
        
        result = {
            "command": "complete-task",
            "task_number": task_number,
            "success": False,
            "updated_lines": 0
        }
        
        try:
            if not self.todo_file.exists():
                result["error"] = f"Todo file not found: {self.todo_file}"
                return result
            
            with open(self.todo_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏
            updated_content, updated_lines = self._mark_task_complete(
                content, task_number, completion_note
            )
            
            if updated_lines > 0:
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Ñ–∞–π–ª
                with open(self.todo_file, 'w', encoding='utf-8') as f:
                    f.write(updated_content)
                
                result.update({
                    "success": True,
                    "updated_lines": updated_lines,
                    "message": f"–ó–∞–¥–∞—á–∞ {task_number} –æ—Ç–º–µ—á–µ–Ω–∞ –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω–∞—è"
                })
            else:
                result["error"] = f"–ó–∞–¥–∞—á–∞ {task_number} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –∏–ª–∏ —É–∂–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∞"
                
        except Exception as e:
            result["error"] = str(e)
        
        result["duration_ms"] = (time.time() - start_time) * 1000
        return result
    
    def report_progress(self) -> Dict[str, Any]:
        """
        MCP –∫–æ–º–∞–Ω–¥–∞: report-progress
        –í—ã–≤–æ–¥–∏—Ç –ø—Ä–æ–≥—Ä–µ—Å—Å –∏ —Å–ª–µ–¥—É—é—â–∏–µ –∑–∞–¥–∞—á–∏ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.
        """
        start_time = time.time()
        
        result = {
            "command": "report-progress",
            "success": False,
            "progress_summary": "",
            "next_actions": [],
            "completed_count": 0,
            "remaining_count": 0
        }
        
        try:
            if not self.todo_file.exists():
                result["error"] = f"Todo file not found: {self.todo_file}"
                return result
            
            with open(self.todo_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
            completed_tasks = self._parse_completed_tasks(content)
            incomplete_tasks = self._parse_incomplete_tasks(content)
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –æ—Ç—á–µ—Ç –æ –ø—Ä–æ–≥—Ä–µ—Å—Å–µ
            progress_summary = self._generate_progress_summary(completed_tasks, incomplete_tasks)
            next_actions = self._generate_next_actions(incomplete_tasks)
            
            result.update({
                "success": True,
                "progress_summary": progress_summary,
                "next_actions": next_actions,
                "completed_count": len(completed_tasks),
                "remaining_count": len(incomplete_tasks)
            })
                
        except Exception as e:
            result["error"] = str(e)
        
        result["duration_ms"] = (time.time() - start_time) * 1000
        return result
    
    def get_task_status(self) -> Dict[str, Any]:
        """
        MCP –∫–æ–º–∞–Ω–¥–∞: task-status
        –ü–æ–ª—É—á–∞–µ—Ç —Å—Ç–∞—Ç—É—Å –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–∞–¥–∞—á.
        """
        start_time = time.time()
        
        result = {
            "command": "task-status",
            "success": False,
            "all_tasks": [],
            "summary": {}
        }
        
        try:
            if not self.todo_file.exists():
                result["error"] = f"Todo file not found: {self.todo_file}"
                return result
            
            with open(self.todo_file, 'r', encoding='utf-8') as f:
                content = f.read()
            
            # –ü–∞—Ä—Å–∏–º –≤—Å–µ –∑–∞–¥–∞—á–∏
            all_tasks = self._parse_all_tasks(content)
            summary = self._generate_task_summary(all_tasks)
            
            result.update({
                "success": True,
                "all_tasks": all_tasks,
                "summary": summary
            })
                
        except Exception as e:
            result["error"] = str(e)
        
        result["duration_ms"] = (time.time() - start_time) * 1000
        return result
    
    def _parse_incomplete_tasks(self, content: str) -> List[Dict]:
        """–ü–∞—Ä—Å–∏—Ç –Ω–µ–∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏ –∏–∑ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ"""
        tasks = []
        lines = content.split('\n')
        current_task = None
        task_number = 0
        
        for line in lines:
            if line.startswith('### –ó–∞–¥–∞—á–∞') and '‚úÖ –ó–ê–í–ï–†–®–ï–ù–û' not in line:
                task_number += 1
                current_task = {
                    "number": task_number,
                    "title": line.strip(),
                    "subtasks": []
                }
                tasks.append(current_task)
            elif line.strip().startswith('- [ ]') and current_task:
                current_task["subtasks"].append(line.strip())
        
        return tasks
    
    def _parse_completed_tasks(self, content: str) -> List[Dict]:
        """–ü–∞—Ä—Å–∏—Ç –∑–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏ –∏–∑ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ"""
        tasks = []
        lines = content.split('\n')
        task_number = 0
        
        for line in lines:
            if line.startswith('### –ó–∞–¥–∞—á–∞') and '‚úÖ –ó–ê–í–ï–†–®–ï–ù–û' in line:
                task_number += 1
                tasks.append({
                    "number": task_number,
                    "title": line.strip()
                })
        
        return tasks
    
    def _parse_all_tasks(self, content: str) -> List[Dict]:
        """–ü–∞—Ä—Å–∏—Ç –≤—Å–µ –∑–∞–¥–∞—á–∏ –∏–∑ —Å–æ–¥–µ—Ä–∂–∏–º–æ–≥–æ"""
        completed = self._parse_completed_tasks(content)
        incomplete = self._parse_incomplete_tasks(content)
        
        all_tasks = []
        for task in completed:
            task["status"] = "completed"
            all_tasks.append(task)
        for task in incomplete:
            task["status"] = "incomplete"
            all_tasks.append(task)
        
        return all_tasks
    
    def _mark_task_complete(self, content: str, task_number: int, note: str = "") -> tuple:
        """–û—Ç–º–µ—á–∞–µ—Ç –∑–∞–¥–∞—á—É –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—É—é –≤ —Å–æ–¥–µ—Ä–∂–∏–º–æ–º"""
        lines = content.split('\n')
        updated_lines = 0
        task_found = False
        current_task_num = 0
        
        for i, line in enumerate(lines):
            if line.startswith('### –ó–∞–¥–∞—á–∞'):
                current_task_num += 1
                if current_task_num == task_number and '‚úÖ –ó–ê–í–ï–†–®–ï–ù–û' not in line:
                    # –û–±–Ω–æ–≤–ª—è–µ–º –∑–∞–≥–æ–ª–æ–≤–æ–∫ –∑–∞–¥–∞—á–∏
                    lines[i] = line.replace('### –ó–∞–¥–∞—á–∞', '### –ó–∞–¥–∞—á–∞') + ' ‚úÖ –ó–ê–í–ï–†–®–ï–ù–û'
                    if note:
                        lines[i] += f' - {note}'
                    updated_lines += 1
                    task_found = True
            elif task_found and line.strip().startswith('- [ ]'):
                # –û—Ç–º–µ—á–∞–µ–º –ø–æ–¥–∑–∞–¥–∞—á–∏ –∫–∞–∫ –≤—ã–ø–æ–ª–Ω–µ–Ω–Ω—ã–µ
                lines[i] = line.replace('- [ ]', '- [x] ‚úÖ')
                updated_lines += 1
            elif task_found and line.startswith('### –ó–∞–¥–∞—á–∞'):
                # –ü–µ—Ä–µ—Ö–æ–¥–∏–º –∫ —Å–ª–µ–¥—É—é—â–µ–π –∑–∞–¥–∞—á–µ
                break
        
        return '\n'.join(lines), updated_lines
    
    def _generate_progress_summary(self, completed: List, incomplete: List) -> str:
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∫—Ä–∞—Ç–∫–∏–π –æ—Ç—á–µ—Ç –æ –ø—Ä–æ–≥—Ä–µ—Å—Å–µ"""
        total = len(completed) + len(incomplete)
        if total == 0:
            return "–ù–µ—Ç –∑–∞–¥–∞—á –¥–ª—è –æ—Ç—Å–ª–µ–∂–∏–≤–∞–Ω–∏—è"
        
        progress_percent = (len(completed) / total) * 100
        
        summary = f"üìä –ü—Ä–æ–≥—Ä–µ—Å—Å: {len(completed)}/{total} –∑–∞–¥–∞—á –≤—ã–ø–æ–ª–Ω–µ–Ω–æ ({progress_percent:.1f}%)\n"
        
        if completed:
            summary += f"‚úÖ –ó–∞–≤–µ—Ä—à–µ–Ω–Ω—ã–µ –∑–∞–¥–∞—á–∏:\n"
            for task in completed[-3:]:  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 3
                summary += f"  ‚Ä¢ {task['title']}\n"
        
        return summary
    
    def _generate_next_actions(self, incomplete: List) -> List[str]:
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ø–∏—Å–æ–∫ —Å–ª–µ–¥—É—é—â–∏—Ö –¥–µ–π—Å—Ç–≤–∏–π"""
        if not incomplete:
            return ["üéâ –í—Å–µ –∑–∞–¥–∞—á–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω—ã! –ú–æ–∂–Ω–æ –ø—Ä–∏—Å—Ç—É–ø–∞—Ç—å –∫ –Ω–æ–≤—ã–º –ø—Ä–æ–µ–∫—Ç–∞–º."]
        
        actions = []
        next_task = incomplete[0]
        actions.append(f"üéØ –°–ª–µ–¥—É—é—â–∞—è –∑–∞–¥–∞—á–∞: {next_task['title']}")
        
        if next_task['subtasks']:
            actions.append(f"üìã –ü–æ–¥–∑–∞–¥–∞—á–∏ ({len(next_task['subtasks'])}):")
            for subtask in next_task['subtasks'][:3]:  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 3
                actions.append(f"  {subtask}")
        
        return actions
    
    def _generate_task_summary(self, all_tasks: List) -> Dict:
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–≤–æ–¥–∫—É –ø–æ –≤—Å–µ–º –∑–∞–¥–∞—á–∞–º"""
        completed = [t for t in all_tasks if t['status'] == 'completed']
        incomplete = [t for t in all_tasks if t['status'] == 'incomplete']
        
        return {
            "total_tasks": len(all_tasks),
            "completed_tasks": len(completed),
            "incomplete_tasks": len(incomplete),
            "completion_rate": (len(completed) / len(all_tasks) * 100) if all_tasks else 0
        }

def test_task_manager():
    """–¢–µ—Å—Ç —Å–∏—Å—Ç–µ–º—ã —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∞–º–∏"""
    print("üß™ –¢–µ—Å—Ç Task Manager MCP Module")
    
    manager = TaskManager()
    
    # –¢–µ—Å—Ç –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ª–µ–¥—É—é—â–µ–π –∑–∞–¥–∞—á–∏
    print("\nüìã –¢–µ—Å—Ç next-task...")
    next_result = manager.get_next_task()
    if next_result["success"]:
        if next_result["next_task"]:
            print(f"   ‚úÖ –°–ª–µ–¥—É—é—â–∞—è –∑–∞–¥–∞—á–∞: {next_result['next_task']}")
            print(f"   üìä –ü–æ–¥–∑–∞–¥–∞—á: {len(next_result['subtasks'])}")
        else:
            print(f"   üéâ {next_result['context']}")
    
    # –¢–µ—Å—Ç —Å—Ç–∞—Ç—É—Å–∞ –∑–∞–¥–∞—á
    print("\nüìä –¢–µ—Å—Ç task-status...")
    status_result = manager.get_task_status()
    if status_result["success"]:
        summary = status_result["summary"]
        print(f"   ‚úÖ –í—Å–µ–≥–æ –∑–∞–¥–∞—á: {summary['total_tasks']}")
        print(f"   ‚úÖ –í—ã–ø–æ–ª–Ω–µ–Ω–æ: {summary['completed_tasks']}")
        print(f"   üìã –û—Å—Ç–∞–µ—Ç—Å—è: {summary['incomplete_tasks']}")
        print(f"   üìà –ü—Ä–æ–≥—Ä–µ—Å—Å: {summary['completion_rate']:.1f}%")
    
    # –¢–µ—Å—Ç –æ—Ç—á–µ—Ç–∞ –æ –ø—Ä–æ–≥—Ä–µ—Å—Å–µ
    print("\nüìà –¢–µ—Å—Ç report-progress...")
    progress_result = manager.report_progress()
    if progress_result["success"]:
        print(f"   ‚úÖ –û—Ç—á–µ—Ç —Å–≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω")
        print(f"   üìä –í—ã–ø–æ–ª–Ω–µ–Ω–æ: {progress_result['completed_count']}")
        print(f"   üìã –û—Å—Ç–∞–µ—Ç—Å—è: {progress_result['remaining_count']}")
    
    print("\n‚úÖ Task Manager –≥–æ—Ç–æ–≤ –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é!")

if __name__ == "__main__":
    test_task_manager()
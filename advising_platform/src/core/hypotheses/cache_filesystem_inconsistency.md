# Гипотеза: Причины несоответствия кеша и файловой системы

**Дата:** 20 мая 2025  
**Автор:** AI Assistant

## Описание проблемы

В процессе работы с системой наблюдаются случаи рассинхронизации между кешем (`.cache_state.json` и `.cache_detailed_state.json`) и актуальным состоянием файловой системы. Это приводит к ряду проблем:

1. Операции с файлами используют устаревшие метаданные
2. Проверки целостности файлов дают ложноположительные результаты
3. Система версионирования работает некорректно, пропуская изменения
4. Пользовательский интерфейс отображает неактуальные данные

Эта проблема особенно критична в контексте системы автопротокола версификации, где пропуск изменений может привести к потере истории документов.

## Гипотезы о причинах

### Гипотеза 1: Гонки данных при многопоточной работе

**Описание:** При одновременном доступе к файлу из разных потоков происходит конфликт между операциями чтения/записи и обновлением кеша.

**Механизм:**
1. Поток A начинает запись в файл
2. Поток B считывает информацию о файле из кеша
3. Поток A завершает запись и обновляет кеш
4. Поток B использует устаревшие данные и перезаписывает кеш устаревшей информацией

**Признаки:**
- Проблема чаще возникает при высокой нагрузке
- Рассинхронизация обычно касается размера файла и времени изменения
- Проблема воспроизводится непредсказуемо

### Гипотеза 2: Отсутствие транзакционности в операциях с кешем

**Описание:** Операции с файлами и обновление кеша выполняются как отдельные операции, без атомарной транзакционности.

**Механизм:**
1. Запись в файл выполняется успешно
2. Из-за исключения или другой ошибки обновление кеша не происходит
3. Состояние системы становится несогласованным

**Признаки:**
- Наличие в логах ошибок, связанных с записью в кеш
- Частое обнаружение файлов, отсутствующих в кеше
- Ошибки часто происходят после сбоев системы или прерываний операций

### Гипотеза 3: Некорректная обработка временных файлов

**Описание:** Система не различает постоянные и временные файлы, что приводит к загрязнению кеша.

**Механизм:**
1. Создаются временные файлы при операциях записи
2. Эти файлы добавляются в кеш
3. После завершения операции временные файлы удаляются
4. Кеш содержит записи о несуществующих файлах

**Признаки:**
- Большое количество "фантомных" файлов в кеше
- Файлы с паттернами временных имен в логах синхронизации
- Постепенное увеличение размера кеша без соответствующего роста файловой системы

### Гипотеза 4: Различие в методах определения времени модификации

**Описание:** Система использует разные методы определения времени изменения файла при записи и при проверке.

**Механизм:**
1. При записи файла используется один метод получения времени модификации
2. При проверке синхронизации используется другой метод
3. Из-за различий в точности или округлении возникают ложные расхождения

**Признаки:**
- Рассинхронизация часто касается только времени изменения
- Разница во времени обычно небольшая (миллисекунды)
- Проблема более выражена на разных операционных системах

## План проверки гипотез

### Для проверки Гипотезы 1 (гонки данных):

1. **Инструментирование кода:** Добавить подробное логирование всех операций с файлами и кешем с точными временными метками
2. **Стресс-тест:** Создать сценарий с параллельным доступом к одним и тем же файлам из нескольких потоков
3. **Анализ блокировок:** Проверить работу системы блокировок файлов и выявить возможные слабые места

### Для проверки Гипотезы 2 (отсутствие транзакционности):

1. **Моделирование сбоев:** Имитировать сбои в различных точках процесса записи файла и обновления кеша
2. **Аудит кода:** Проанализировать все пути выполнения операций с файлами на предмет возможного пропуска обновления кеша
3. **Проверка восстановления:** Оценить, насколько эффективно система восстанавливается после сбоев

### Для проверки Гипотезы 3 (временные файлы):

1. **Анализ кеша:** Изучить содержимое кеша на предмет наличия записей о временных файлах
2. **Мониторинг операций:** Отслеживать создание и удаление временных файлов во время операций записи
3. **Фильтрация:** Проверить эффективность механизма фильтрации временных файлов в системе кеширования

### Для проверки Гипотезы 4 (различия в методах определения времени):

1. **Сравнительный анализ:** Использовать разные методы получения времени модификации файла и сравнить результаты
2. **Кросс-платформенное тестирование:** Проверить поведение на разных операционных системах
3. **Изменение точности:** Варьировать точность сравнения времен для определения оптимального порога

## Предлагаемые решения

### Решение 1: Усиленная блокировка и атомарные операции

- Реализовать более строгую систему блокировок для предотвращения гонок данных
- Ввести атомарные транзакции для операций с файлами и кешем
- Использовать двухфазный коммит для обеспечения целостности данных

### Решение 2: Автоматическая верификация и восстановление

- Внедрить автоматическую периодическую проверку целостности кеша
- Реализовать механизм самовосстановления при обнаружении рассинхронизации
- Создать систему журналирования операций для возможности отката

### Решение 3: Улучшенное управление временными файлами

- Внедрить четкую маркировку временных файлов
- Исключить временные файлы из системы кеширования
- Добавить периодическую очистку устаревших временных файлов

### Решение 4: Унифицированные методы работы со временем

- Разработать единый интерфейс для работы с временем модификации файлов
- Внедрить настраиваемую точность сравнения времен для разных типов файлов
- Добавить дополнительные метрики для определения изменений файлов, помимо времени модификации

## Критерии успеха

Решение проблемы будет считаться успешным, если:

1. Число инцидентов рассинхронизации снизится на 90% в течение недели после внедрения
2. Система сможет обнаруживать и автоматически исправлять более 95% случаев рассинхронизации
3. Производительность операций с файлами не снизится более чем на 5% по сравнению с текущей реализацией
4. Общая стабильность системы повысится, что выразится в снижении числа инцидентов, связанных с файловыми операциями

## План внедрения

1. **Этап 1 - Диагностика (1-2 дня)**
   - Улучшить систему логирования
   - Провести стресс-тесты
   - Подтвердить или опровергнуть выдвинутые гипотезы

2. **Этап 2 - Прототипирование (2-3 дня)**
   - Разработать прототипы решений для подтвержденных гипотез
   - Провести тестирование прототипов в изолированной среде
   - Оценить эффективность и выбрать оптимальный подход

3. **Этап 3 - Внедрение (3-4 дня)**
   - Реализовать выбранное решение
   - Провести тщательное тестирование на реальных данных
   - Постепенно внедрить изменения в продакшн

4. **Этап 4 - Мониторинг и оптимизация (постоянно)**
   - Отслеживать эффективность решения
   - Собирать метрики и корректировать параметры
   - Итеративно улучшать реализацию на основе реальных данных
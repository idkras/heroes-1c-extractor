"""
Модуль обработчика триггеров для задач и инцидентов.
Предоставляет единый интерфейс для обработки различных типов триггеров.
"""

import logging
import traceback
import os
import re
import json
import time
from typing import Any, Dict, List, Optional, Tuple, Callable
from datetime import datetime, timedelta

# Настраиваем логирование
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class TriggerType:
    """Типы триггеров."""
    TASK_CREATE = "task_create"  
    TASK_UPDATE = "task_update"  
    INCIDENT_CREATE = "incident_create"  
    INCIDENT_UPDATE = "incident_update"  
    HYPOTHESIS_CREATE = "hypothesis_create"  
    HYPOTHESIS_UPDATE = "hypothesis_update"  
    STANDARD_CREATE = "standard_create"  
    STANDARD_UPDATE = "standard_update"  
    CACHE_SYNC = "cache_sync"  
    PERIODIC_CHECK = "periodic_check"
    FILE_DUPLICATION_CHECK = "file_duplication_check"

class TriggerResult:
    """Результат обработки триггера."""
    def __init__(self, success: bool = False, message: str = "", data: Optional[Dict[str, Any]] = None):
        self.success = success
        self.message = message
        self.data = data or {}
        
    def __str__(self) -> str:
        return f"TriggerResult(success={self.success}, message={self.message}, data={self.data})"

class TriggerContext:
    """Контекст триггера."""
    def __init__(self, trigger_type: Any, data: Dict[str, Any], timestamp: Optional[float] = None, source: Optional[str] = None):
        self.trigger_type = trigger_type
        self.data = data
        self.timestamp = timestamp or time.time()
        self.source = source
        
    def __str__(self) -> str:
        return f"TriggerContext(type={self.trigger_type}, source={self.source}, timestamp={self.timestamp})"

class TriggerHandler:
    """Обработчик триггеров."""
    
    _instance = None
    
    def __init__(self, report_progress_func: Optional[Callable] = None):
        """
        Инициализирует обработчик триггеров.
        
        Args:
            report_progress_func: Функция для отчета о прогрессе
        """
        self.handlers = {
            TriggerType.FILE_DUPLICATION_CHECK: self._handle_file_duplication_check,}
        self.report_progress_func = report_progress_func
        
        # Регистрируем обработчики по умолчанию
        self._register_default_handlers()
        
    def _register_default_handlers(self):
        """Регистрирует обработчики по умолчанию."""
        self.register_handler(TriggerType.TASK_CREATE, self._handle_task_create)
        self.register_handler(TriggerType.TASK_UPDATE, self._handle_task_update)
        self.register_handler(TriggerType.INCIDENT_CREATE, self._handle_incident_create)
        self.register_handler(TriggerType.INCIDENT_UPDATE, self._handle_incident_update)
        self.register_handler(TriggerType.HYPOTHESIS_CREATE, self._handle_hypothesis_create)
        self.register_handler(TriggerType.HYPOTHESIS_UPDATE, self._handle_hypothesis_update)
        self.register_handler(TriggerType.STANDARD_CREATE, self._handle_standard_create)
        self.register_handler(TriggerType.STANDARD_UPDATE, self._handle_standard_update)
        self.register_handler(TriggerType.CACHE_SYNC, self._handle_cache_sync)
        self.register_handler(TriggerType.PERIODIC_CHECK, self._handle_periodic_check)
        self.register_handler(TriggerType.FILE_DUPLICATION_CHECK, self._handle_file_duplication_check)
        
    def register_handler(self, trigger_type: str, handler_func: Callable) -> bool:
        """
        Регистрирует функцию-обработчик для указанного типа триггера.
        
        Args:
            trigger_type: Тип триггера
            handler_func: Функция-обработчик
            
        Returns:
            bool: True, если регистрация успешна, иначе False
        """
        if trigger_type in self.handlers:
            logger.warning(f"Обработчик для триггера {trigger_type} уже зарегистрирован, он будет перезаписан")
            
        self.handlers[trigger_type] = handler_func
        return True
        
    def trigger(self, context: TriggerContext) -> bool:
        """
        Запускает обработку триггера.
        
        Args:
            context: Контекст триггера
            
        Returns:
            bool: True, если обработка прошла успешно, иначе False
        """
        result = self.handle_trigger(context)
        return result.success
        
    def handle_trigger(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        trigger_type = context.trigger_type
        
        if trigger_type not in self.handlers:
            logger.error(f"Неизвестный тип триггера: {trigger_type}")
            return TriggerResult(success=False, message=f"Неизвестный тип триггера: {trigger_type}")
            
        try:
            handler = self.handlers[trigger_type]
            result = handler(context)
            
            # Если обработчик вернул не TriggerResult, а что-то другое, оборачиваем в TriggerResult
            if not isinstance(result, TriggerResult):
                result = TriggerResult(success=True, message="Триггер обработан", data={"result": result})
                
            return result
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера {trigger_type}: {e}")
            traceback.print_exc()
            return TriggerResult(success=False, message=f"Ошибка при обработке триггера: {e}")
    
    def _handle_task_create(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер создания задачи.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        try:
            # Извлекаем данные из контекста
            data = context.data
            title = data.get("title", "")
            description = data.get("description", "")
            properties = data.get("properties", {})
            
            # 1. Архивация завершенных задач
            archived_count = self._archive_completed_tasks()
            logger.info(f"Архивировано {archived_count} завершенных задач")
            
            # 2. Проверка на дубликаты
            duplicates = self._check_task_duplicates(title, description)
            
            if duplicates:
                logger.warning(f"Найдены возможные дубликаты задачи '{title}': {duplicates}")
                
            # 3. Обновление статистики
            stats = self._update_task_statistics(title, properties)
            
            # 4. Отчет о прогрессе
            if self.report_progress_func:
                self.report_progress_func({
                    "event": "task_created",
                    "title": title,
                    "stats": stats,
                    "archived_count": archived_count,
                    "duplicates": duplicates
                })
                
            return TriggerResult(
                success=True,
                message=f"Задача '{title}' успешно создана",
                data={
                    "title": title,
                    "stats": stats,
                    "archived_count": archived_count,
                    "duplicates": duplicates
                }
            )
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера создания задачи: {e}")
            traceback.print_exc()
            
            return TriggerResult(success=False, message=f"Ошибка при обработке триггера создания задачи: {e}")
    
    def _archive_completed_tasks(self) -> int:
        """
        Архивирует завершенные задачи.
        
        Returns:
            int: Количество архивированных задач
        """
        # Здесь будет реализация архивации задач
        return 0
    
    def _check_task_duplicates(self, title: str, description: str) -> list:
        """
        Проверяет наличие дубликатов задачи.
        
        Args:
            title: Название задачи
            description: Описание задачи
            
        Returns:
            list: Список возможных дубликатов
        """
        # Здесь будет реализация проверки дубликатов
        return []
    
    def _update_task_statistics(self, title: str, properties: dict) -> dict:
        """
        Обновляет статистику по задачам.
        
        Args:
            title: Название задачи
            properties: Свойства задачи
            
        Returns:
            dict: Обновленная статистика
        """
        # Здесь будет реализация обновления статистики
        return {}
    
    def _handle_task_update(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер обновления задачи.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Реализация обработки триггера обновления задачи
        return TriggerResult(success=True, message="Задача обновлена")
    
    def _handle_incident_create(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер создания инцидента.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        try:
            # Извлекаем данные из контекста
            data = context.data
            title = data.get("title", "")
            description = data.get("description", "")
            properties = data.get("properties", {})
            
            # 1. Извлечение 5-почему анализа
            five_whys_from_context = data.get("five_whys", [])
            
            if five_whys_from_context:
                five_whys = five_whys_from_context
                logger.info(f"Найден 5-почему анализ в контексте триггера: {len(five_whys)} вопросов")
            else:
                # Если в контексте нет, извлекаем из описания
                five_whys = self._extract_five_whys(description)
                logger.info(f"Найден 5-почему анализ в описании: {len(five_whys)} вопросов")
            
            # 2. Обновление статистики по инцидентам
            incident_stats = self._update_incident_statistics(title, properties)
            
            # 3. Проверка связанных инцидентов
            related_incidents = self._check_related_incidents(title, description)
            
            # 4. Отчет о прогрессе
            if self.report_progress_func:
                self.report_progress_func({
                    "event": "incident_created",
                    "title": title,
                    "five_whys_count": len(five_whys),
                    "stats": incident_stats,
                    "related_incidents": related_incidents
                })
                
            return TriggerResult(
                success=True,
                message=f"Инцидент '{title}' успешно создан",
                data={
                    "title": title,
                    "five_whys": five_whys,
                    "stats": incident_stats,
                    "related_incidents": related_incidents
                }
            )
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера создания инцидента: {e}")
            traceback.print_exc()
            
            return TriggerResult(success=False, message=f"Ошибка при обработке триггера создания инцидента: {e}")
    
        def _extract_five_whys(self, description: str) -> list:
        """
        Извлекает 5-почему анализ из описания инцидента.
        
        Args:
            description: Описание инцидента
            
        Returns:
            list: Список вопросов и ответов
        """
        try:
            # Проверяем, есть ли в описании раздел 5-почему
            if "почему" not in description.lower() and "why" not in description.lower():
                logger.info("5-почему анализ не найден в описании")
                return []
            
            # Результат
            five_whys_list = []
            
            # Шаблоны для поиска
            patterns = [
                # 1. С номером и вопросительным знаком (Почему #1: ...)
                r"(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)[:\s]*([^\n?]+\?)[\s\n]*(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*|^)[\s\n]*([^\n]+)",
                
                # 2. С номером без вопросительного знака (Почему #1: ...)
                r"(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)[:\s]*([^\n]+)[\s\n]*(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*|^)[\s\n]*([^\n]+)",
                
                # 3. С номером и словом "вопрос" (Вопрос #1: ...)
                r"(?:вопрос|question)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)[:\s]*([^\n]+)[\s\n]*(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*|^)[\s\n]*([^\n]+)",
                
                # 4. С маркерами Markdown
                r"###[\s]*(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)[:\s]*([^\n]+)[\s\n]*(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*|^)[\s\n]*([^\n]+)",
                
                # 5. Общий паттерн для секции Корневая причина
                r"(?:корневая причина|root cause)[:\s]*([^\n]+)"
            ]
            
            # Проверяем каждый шаблон
            for pattern in patterns:
                matches = re.findall(pattern, description, re.IGNORECASE | re.MULTILINE)
                if matches:
                    # Если это шаблон для корневой причины
                    if "корневая причина" in pattern or "root cause" in pattern:
                        # Добавляем корневую причину в качестве отдельного элемента
                        for match in matches:
                            if isinstance(match, tuple):
                                match = match[0]  # Берем только первую группу
                            five_whys_list.append({
                                "type": "root_cause",
                                "content": match.strip()
                            })
                    else:
                        # Обрабатываем вопросы и ответы
                        for match in matches:
                            if isinstance(match, tuple) and len(match) >= 2:
                                question = match[0].strip()
                                answer = match[1].strip()
                                
                                # Добавляем вопрос и ответ к результату
                                five_whys_list.append({
                                    "type": "question_answer",
                                    "question": question,
                                    "answer": answer
                                })
            
            # Если не удалось извлечь вопросы и ответы, пробуем разбить на секции по маркерам Markdown
            if not five_whys_list:
                # Разбиваем текст на секции по маркерам Markdown
                sections = re.split(r"###+", description)
                for section in sections:
                    # Проверяем, содержит ли секция ключевые слова 5-почему
                    if re.search(r"(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)", section, re.IGNORECASE):
                        # Извлекаем заголовок секции и содержимое
                        section_match = re.match(r"([^\n]+)[\n\s]*(.*)", section.strip(), re.DOTALL)
                        if section_match:
                            title = section_match.group(1).strip()
                            content = section_match.group(2).strip()
                            
                            # Проверяем, является ли это вопросом или корневой причиной
                            if re.search(r"(?:корневая причина|root cause)", title, re.IGNORECASE):
                                five_whys_list.append({
                                    "type": "root_cause",
                                    "content": content
                                })
                            else:
                                # Ищем ответ в содержимом секции
                                answer_match = re.search(r"(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*)[\s\n]*([^\n]+)", content, re.IGNORECASE)
                                answer = answer_match.group(1).strip() if answer_match else content
                                
                                five_whys_list.append({
                                    "type": "question_answer",
                                    "question": title,
                                    "answer": answer
                                })
            
            # Если всё ещё нет результатов, ищем блоки текста, разделенные пустыми строками
            if not five_whys_list:
                # Разбиваем текст на блоки, разделенные пустыми строками
                blocks = re.split(r"\n\s*\n", description)
                for block in blocks:
                    block = block.strip()
                    if not block:
                        continue
                    
                    # Проверяем, содержит ли блок ключевые слова 5-почему
                    if re.search(r"(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)", block, re.IGNORECASE):
                        # Разбиваем блок на строки
                        lines = block.split("\n")
                        
                        # Ищем строки с вопросом и ответом
                        for i in range(len(lines) - 1):
                            if re.search(r"(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)", lines[i], re.IGNORECASE):
                                question = lines[i].strip()
                                answer = lines[i + 1].strip()
                                
                                # Проверяем, есть ли в ответе ключевые слова
                                if not re.search(r"(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*)", answer, re.IGNORECASE):
                                    # Если нет, проверяем, есть ли в вопросе двоеточие
                                    if ":" in question:
                                        question_parts = question.split(":", 1)
                                        question = question_parts[0].strip() + "?"
                                        if len(question_parts) > 1 and question_parts[1].strip():
                                            answer = question_parts[1].strip()
                                
                                five_whys_list.append({
                                    "type": "question_answer",
                                    "question": question,
                                    "answer": answer
                                })
                    
                    # Проверяем, содержит ли блок ключевые слова корневой причины
                    elif re.search(r"(?:корневая причина|root cause)", block, re.IGNORECASE):
                        # Разбиваем блок на строки
                        lines = block.split("\n")
                        
                        # Ищем строки с корневой причиной
                        for i in range(len(lines)):
                            if re.search(r"(?:корневая причина|root cause)", lines[i], re.IGNORECASE):
                                # Если это последняя строка или следующая строка пустая, используем текущую строку
                                if i == len(lines) - 1 or not lines[i + 1].strip():
                                    # Извлекаем корневую причину из текущей строки
                                    cause_match = re.search(r"(?:корневая причина|root cause)[:\s]*([^\n]+)", lines[i], re.IGNORECASE)
                                    if cause_match:
                                        five_whys_list.append({
                                            "type": "root_cause",
                                            "content": cause_match.group(1).strip()
                                        })
                                else:
                                    # Используем следующую строку как корневую причину
                                    five_whys_list.append({
                                        "type": "root_cause",
                                        "content": lines[i + 1].strip()
                                    })
                                break
            
            logger.info(f"Найден 5-почему анализ в описании: {len(five_whys_list)} элементов")
            return five_whys_list
        except Exception as e:
            logger.error(f"Ошибка при извлечении 5-почему анализа: {e}")
            traceback.print_exc()
            return []def _update_incident_statistics(self, title: str, properties: dict) -> dict:
        """
        Обновляет статистику по инцидентам.
        
        Args:
            title: Название инцидента
            properties: Свойства инцидента
            
        Returns:
            dict: Обновленная статистика
        """
        # Здесь будет реализация обновления статистики
        return {}
    
    def _check_related_incidents(self, title: str, description: str) -> list:
        """
        Проверяет наличие связанных инцидентов.
        
        Args:
            title: Название инцидента
            description: Описание инцидента
            
        Returns:
            list: Список связанных инцидентов
        """
        # Здесь будет реализация проверки связанных инцидентов
        return []
    
    def _handle_incident_update(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер обновления инцидента.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Реализация обработки триггера обновления инцидента
        return TriggerResult(success=True, message="Инцидент обновлен")
    
    def _handle_hypothesis_create(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер создания гипотезы.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Реализация обработки триггера создания гипотезы
        return TriggerResult(success=True, message="Гипотеза создана")
    
    def _handle_hypothesis_update(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер обновления гипотезы.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Реализация обработки триггера обновления гипотезы
        return TriggerResult(success=True, message="Гипотеза обновлена")
    
    def _handle_standard_create(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер создания стандарта.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Реализация обработки триггера создания стандарта
        return TriggerResult(success=True, message="Стандарт создан")
    
    def _handle_standard_update(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер обновления стандарта.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Реализация обработки триггера обновления стандарта
        return TriggerResult(success=True, message="Стандарт обновлен")
    
    def _handle_cache_sync(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер синхронизации кеша.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Реализация обработки триггера синхронизации кеша
        return TriggerResult(success=True, message="Кеш синхронизирован")
    
    def _handle_file_duplication_check(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер проверки дублирования файлов.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        try:
            data = context.data
            file_paths = data.get("file_paths", [])
            
            if not file_paths:
                return TriggerResult(
                    success=False,
                    message="Не указаны пути к файлам для проверки дублирования"
                )
            
            # Фильтруем только скрипты Python
            script_files = [path for path in file_paths if path.endswith('.py')]
            
            if not script_files:
                return TriggerResult(
                    success=True,
                    message="Нет скриптов для проверки дублирования"
                )
            
            # Заглушка для проверки дублирования кода
            return TriggerResult(
                success=True,
                message=f"Проверка дублирования файлов завершена, проверено {len(script_files)} файлов",
                data={"duplications": []}
            )
        except Exception as e:
            logger.error(f"Ошибка при проверке дублирования файлов: {e}")
            traceback.print_exc()
            return TriggerResult(success=False, message=f"Ошибка при проверке дублирования файлов: {e}")
    
    def _handle_periodic_check(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер периодической проверки.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Реализация обработки триггера периодической проверки
        return TriggerResult(success=True, message="Периодическая проверка выполнена")

# Глобальные функции для получения экземпляра обработчика триггеров

def get_handler(report_progress_func: Optional[Callable] = None) -> TriggerHandler:
    """
    Возвращает экземпляр обработчика триггеров (синглтон).
    
    Args:
        report_progress_func: Функция для отчета о прогрессе
        
    Returns:
        TriggerHandler: Экземпляр обработчика триггеров
    """
    if not TriggerHandler._instance:
        TriggerHandler._instance = TriggerHandler(report_progress_func)
    return TriggerHandler._instance

def get_trigger_handler_instance(report_progress_func: Optional[Callable] = None) -> TriggerHandler:
    """
    Возвращает экземпляр обработчика триггеров для совместимости.
    Обертка вокруг функции get_handler.
    
    Args:
        report_progress_func: Функция для отчета о прогрессе
        
    Returns:
        TriggerHandler: Экземпляр обработчика триггеров
    """
    return get_handler(report_progress_func)
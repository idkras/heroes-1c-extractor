#!/usr/bin/env python3
"""
Модуль обработчика триггеров для задач и инцидентов.
Предоставляет единый интерфейс для обработки различных типов триггеров.
"""

import os
import sys
import logging
import traceback
import time
import re
import json
import shutil
from datetime import datetime
from typing import Dict, List, Any, Optional, Callable, Union, Tuple

# Настройка логирования
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger("trigger_handler")

# Глобальный экземпляр обработчика триггеров
_trigger_handler_instance = None

class TriggerType:
    FILE_DUPLICATION_CHECK = "file_duplication_check"  # Новый тип для проверки дублирования файлов
    """Типы триггеров."""
    TASK_CREATE = "task_create"  
    TASK_UPDATE = "task_update"  
    INCIDENT_CREATE = "incident_create"  
    INCIDENT_UPDATE = "incident_update"  
    HYPOTHESIS_CREATE = "hypothesis_create"  
    HYPOTHESIS_UPDATE = "hypothesis_update"  
    STANDARD_CREATE = "standard_create"  
    STANDARD_UPDATE = "standard_update"  
    CACHE_SYNC = "cache_sync"  
    PERIODIC_CHECK = "periodic_check"  

class TriggerResult:
    """Результат обработки триггера."""
    def __init__(self, success: bool = False, message: str = "", data: Optional[Dict[str, Any]] = None):
        self.success = success
        self.message = message
        self.data = data or {}

class TriggerContext:
    """Контекст триггера."""
    def __init__(self, trigger_type: Any, data: Dict[str, Any], timestamp: Optional[float] = None, source: Optional[str] = None):
        self.trigger_type = trigger_type
        self.data = data
        self.timestamp = timestamp or time.time()
        self.source = source or "unknown"
        self.result = None

class TriggerHandler:
    """Обработчик триггеров."""
    
    def __init__(self, report_progress_func: Optional[Callable] = None):
        """
        Инициализирует обработчик триггеров.
        
        Args:
            report_progress_func: Функция для отчета о прогрессе
        """
        self.report_progress = report_progress_func
        self.handlers = {
            TriggerType.FILE_DUPLICATION_CHECK: self._handle_file_duplication_check,
            TriggerType.TASK_CREATE: self._handle_task_create,
            TriggerType.TASK_UPDATE: self._handle_task_update,
            TriggerType.INCIDENT_CREATE: self._handle_incident_create,
            TriggerType.INCIDENT_UPDATE: self._handle_incident_update,
            TriggerType.HYPOTHESIS_CREATE: self._handle_hypothesis_create,
            TriggerType.HYPOTHESIS_UPDATE: self._handle_hypothesis_update,
            TriggerType.STANDARD_CREATE: self._handle_standard_create,
            TriggerType.STANDARD_UPDATE: self._handle_standard_update,
            TriggerType.CACHE_SYNC: self._handle_cache_sync,
            TriggerType.PERIODIC_CHECK: self._handle_periodic_check
        }
        self.custom_handlers = {}
        logger.info("Обработчик триггеров инициализирован")
        
    def register_handler(self, trigger_type: str, handler_func: Callable) -> bool:
        """
        Регистрирует функцию-обработчик для указанного типа триггера.
        
        Args:
            trigger_type: Тип триггера
            handler_func: Функция-обработчик
            
        Returns:
            bool: True, если регистрация успешна, иначе False
        """
        try:
            self.custom_handlers[trigger_type] = handler_func
            logger.info(f"Зарегистрирован обработчик для триггера типа {trigger_type}")
            return True
        except Exception as e:
            logger.error(f"Ошибка при регистрации обработчика для триггера типа {trigger_type}: {e}")
            traceback.print_exc()
            return False
    
    def trigger(self, context: TriggerContext) -> bool:
        """
        Запускает обработку триггера.
        
        Args:
            context: Контекст триггера
            
        Returns:
            bool: True, если обработка прошла успешно, иначе False
        """
        try:
            result = self.handle_trigger(context)
            return result.success
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера {context.trigger_type}: {e}")
            traceback.print_exc()
            return False
    
    def handle_trigger(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        logger.info(f"Обработка триггера типа {context.trigger_type} из источника {context.source}")
        try:
            # Сначала проверяем наличие пользовательского обработчика
            handler_func = None
            if context.trigger_type in self.custom_handlers:
                handler_func = self.custom_handlers[context.trigger_type]
                logger.info(f"Найден пользовательский обработчик для триггера {context.trigger_type}")
            # Если пользовательского обработчика нет, используем встроенный
            elif context.trigger_type in self.handlers:
                handler_func = self.handlers[context.trigger_type]
                logger.info(f"Найден встроенный обработчик для триггера {context.trigger_type}")
            else:
                logger.warning(f"Нет обработчика для триггера типа: {context.trigger_type}")
                return TriggerResult(success=False, message=f"Нет обработчика для триггера типа: {context.trigger_type}")
            
            # Логируем начало обработки
            logger.info(f"Обработка триггера: {context.trigger_type} от {context.source}")
            
            # Обрабатываем триггер
            result = handler_func(context)
            
            # Логируем результат
            if result.success:
                logger.info(f"Обработка триггера {context.trigger_type} успешно завершена: {result.message}")
            else:
                logger.warning(f"Обработка триггера {context.trigger_type} завершилась с ошибкой: {result.message}")
            
            # Отчитываемся о прогрессе, если доступна функция отчета
            if self.report_progress and result.success:
                self.report_progress({
                    "type": context.trigger_type,
                    "status": "success" if result.success else "error",
                    "message": result.message
                })
            
            return result
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера {context.trigger_type}: {e}")
            traceback.print_exc()
            
            return TriggerResult(success=False, message=f"Ошибка при обработке триггера: {e}")
    
    def _handle_task_create(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер создания задачи.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        try:
            # Извлекаем данные из контекста
            title = context.data.get("title", "Без названия")
            description = context.data.get("description", "")
            file_path = context.data.get("file_path", "")
            properties = context.data.get("properties", {})
            
            # 1. Архивирование завершенных задач
            self._archive_completed_tasks()
            
            # 2. Проверка на дубликаты задач
            duplicate_tasks = self._check_task_duplicates(title, description)
            if duplicate_tasks:
                logger.warning(f"Обнаружены возможные дубликаты задачи '{title}': {duplicate_tasks}")
                
                # Сообщаем о дубликатах в отчете о прогрессе
                if self.report_progress:
                    self.report_progress({
                        "type": "task_duplicate_warning",
                        "title": title,
                        "duplicates": duplicate_tasks,
                        "message": f"Внимание! Обнаружены возможные дубликаты задачи '{title}'"
                    })
            
            # 3. Обновление статистики по задачам
            task_stats = self._update_task_statistics(title, properties)
            
            # 4. Вывод статистики через report_progress
            if self.report_progress:
                self.report_progress({
                    "type": "task_statistics",
                    "title": "Обновлена статистика задач",
                    "statistics": task_stats,
                    "message": f"Задача '{title}' добавлена в систему"
                })
            
            return TriggerResult(
                success=True,
                message=f"Задача '{title}' успешно создана и обработана",
                data={
                    "task_id": file_path,
                    "statistics": task_stats,
                    "duplicates": duplicate_tasks
                }
            )
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера создания задачи: {e}")
            traceback.print_exc()
            
            return TriggerResult(success=False, message=f"Ошибка при обработке триггера создания задачи: {e}")
    
    def _archive_completed_tasks(self) -> int:
        """
        Архивирует завершенные задачи.
        
        Returns:
            int: Количество архивированных задач
        """
        try:
            # Поиск завершенных задач
            completed_tasks = []
            # Папка с задачами
            tasks_folder = "todo"
            
            if os.path.exists(tasks_folder):
                for file_name in os.listdir(tasks_folder):
                    if file_name.endswith(".md") and "task_" in file_name:
                        file_path = os.path.join(tasks_folder, file_name)
                        with open(file_path, 'r', encoding='utf-8') as file:
                            content = file.read()
                            # Проверяем, что задача завершена
                            if "## Статус: Завершена" in content or "## Статус: Выполнена" in content:
                                completed_tasks.append(file_path)
            
            # Создаем папку для архива, если она не существует
            archive_folder = os.path.join("archive", "tasks", datetime.now().strftime("%Y-%m"))
            os.makedirs(archive_folder, exist_ok=True)
            
            # Архивируем задачи
            archived_count = 0
            for task_path in completed_tasks:
                try:
                    # Получаем название файла
                    file_name = os.path.basename(task_path)
                    # Путь в архиве
                    archive_path = os.path.join(archive_folder, file_name)
                    # Переносим файл в архив
                    shutil.move(task_path, archive_path)
                    archived_count += 1
                    logger.info(f"Задача {task_path} перемещена в архив {archive_path}")
                except Exception as move_error:
                    logger.error(f"Ошибка при архивировании задачи {task_path}: {move_error}")
            
            # Вывод информации в лог и через report_progress
            logger.info(f"Архивировано {archived_count} завершенных задач")
            
            if self.report_progress and archived_count > 0:
                self.report_progress({
                    "type": "tasks_archived",
                    "count": archived_count,
                    "message": f"Архивировано {archived_count} завершенных задач"
                })
            
            return archived_count
        except Exception as e:
            logger.error(f"Ошибка при архивировании задач: {e}")
            traceback.print_exc()
            return 0
    
    def _check_task_duplicates(self, title: str, description: str) -> list:
        """
        Проверяет наличие дубликатов задачи.
        
        Args:
            title: Название задачи
            description: Описание задачи
            
        Returns:
            list: Список возможных дубликатов
        """
        try:
            # Здесь будет код для проверки дубликатов
            # В реальной реализации нужно подключить соответствующий модуль
            
            # Симуляция проверки дубликатов
            # Для демонстрации предположим, что дубликатов нет
            duplicates = []
            
            return duplicates
        except Exception as e:
            logger.error(f"Ошибка при проверке дубликатов задачи: {e}")
            return []
    
    def _update_task_statistics(self, title: str, properties: dict) -> dict:
        """
        Обновляет статистику по задачам.
        
        Args:
            title: Название задачи
            properties: Свойства задачи
            
        Returns:
            dict: Обновленная статистика
        """
        try:
            # Здесь будет код для обновления статистики
            # В реальной реализации нужно подключить соответствующий модуль
            
            # Симуляция статистики
            stats = {
                "total_tasks": 42,  # Общее количество задач
                "active_tasks": 28,  # Активные задачи
                "completed_tasks": 14,  # Завершенные задачи
                "by_category": {  # Статистика по категориям
                    "bug": 12,
                    "feature": 15,
                    "refactor": 8,
                    "documentation": 7
                },
                "by_priority": {  # Статистика по приоритетам
                    "high": 10,
                    "medium": 20,
                    "low": 12
                }
            }
            
            # Добавляем категорию из текущей задачи, если она есть
            category = properties.get("category", "unknown")
            if category in stats["by_category"]:
                stats["by_category"][category] += 1
            else:
                stats["by_category"][category] = 1
            
            # Добавляем приоритет из текущей задачи, если он есть
            priority = properties.get("priority", "medium")
            if priority in stats["by_priority"]:
                stats["by_priority"][priority] += 1
            else:
                stats["by_priority"][priority] = 1
            
            # Увеличиваем общее количество и активные задачи
            stats["total_tasks"] += 1
            stats["active_tasks"] += 1
            
            logger.info(f"Обновлена статистика задач после добавления '{title}'")
            
            return stats
        except Exception as e:
            logger.error(f"Ошибка при обновлении статистики задач: {e}")
            return {}
    
    def _handle_task_update(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер обновления задачи.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Реализация обработки триггера обновления задачи
        return TriggerResult(success=True, message="Задача обновлена")
    
    def _handle_incident_create(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер создания инцидента.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        try:
            # Извлекаем данные из контекста
            title = context.data.get("title", "Без названия")
            description = context.data.get("description", "")
            file_path = context.data.get("file_path", "")
            properties = context.data.get("properties", {})
            
            # 1. Проверка 5-почему анализа
            # Сначала проверяем, есть ли 5-почему в данных контекста
            five_whys_from_context = context.data.get("five_whys", [])
            if five_whys_from_context:
                five_whys = five_whys_from_context
                logger.info(f"Найден 5-почему анализ в контексте триггера: {len(five_whys)} вопросов")
            else:
                # Если в контексте нет, извлекаем из описания
                five_whys = self._extract_five_whys(description)
                logger.info(f"Найден 5-почему анализ в описании: {len(five_whys)} вопросов")
            
            # 2. Обновление статистики по инцидентам
            incident_stats = self._update_incident_statistics(title, properties)
            
            # 3. Проверка на повторение инцидентов
            related_incidents = self._check_related_incidents(title, description)
            
            # 4. Отправка отчета через report_progress
            if self.report_progress:
                # Отчет о статистике инцидентов
                self.report_progress({
                    "type": "incident_statistics",
                    "title": "Обновлена статистика инцидентов",
                    "statistics": incident_stats,
                    "message": f"Инцидент '{title}' добавлен в систему"
                })
                
                # Если есть 5-почему анализ, выводим его
                if five_whys:
                    logger.info(f"Отправка отчета о 5-почему анализе через report_progress")
                    # Формируем удобный для чтения текст анализа
                    five_whys_text = ""
                    for i, why in enumerate(five_whys):
                        question = why.get("question", f"Почему #{i+1}")
                        evidence = why.get("evidence", "Нет данных")
                        five_whys_text += f"\n**{question}**\n- *Доказательство:* {evidence}\n"
                    
                    # Добавляем корневую причину, если она есть
                    root_cause = context.data.get("root_cause", "")
                    if root_cause:
                        five_whys_text += f"\n**Корневая причина:**\n{root_cause}\n"
                    
                    # Отправляем отчет о 5-почему анализе
                    self.report_progress({
                        "type": "incident_five_whys",
                        "title": f"5-почему анализ для инцидента '{title}'",
                        "text": five_whys_text,
                        "five_whys": five_whys,
                        "root_cause": root_cause,
                        "message": f"5-почему анализ для инцидента '{title}'"
                    })
                
                # Если есть связанные инциденты, выводим предупреждение
                if related_incidents:
                    self.report_progress({
                        "type": "incident_related_warning",
                        "title": title,
                        "related_incidents": related_incidents,
                        "message": f"Внимание! Обнаружены похожие инциденты для '{title}'"
                    })
            
            return TriggerResult(
                success=True,
                message=f"Инцидент '{title}' успешно создан и обработан",
                data={
                    "incident_id": file_path,
                    "statistics": incident_stats,
                    "five_whys": five_whys,
                    "related_incidents": related_incidents
                }
            )
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера создания инцидента: {e}")
            traceback.print_exc()
            
            return TriggerResult(success=False, message=f"Ошибка при обработке триггера создания инцидента: {e}")
    
        def _extract_five_whys(self, description: str) -> list:
        """
        Извлекает 5-почему анализ из описания инцидента.
        
        Args:
            description: Описание инцидента
            
        Returns:
            list: Список вопросов и ответов
        """
        try:
            # Проверяем, есть ли в описании раздел 5-почему
            if "почему" not in description.lower() and "why" not in description.lower():
                logger.info("5-почему анализ не найден в описании")
                return []
            
            # Результат
            five_whys_list = []
            
            # Шаблоны для поиска
            patterns = [
                # 1. С номером и вопросительным знаком (Почему #1: ...)
                r"(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)[:\s]*([^\n?]+\?)[\s\n]*(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*|^)[\s\n]*([^\n]+)",
                
                # 2. С номером без вопросительного знака (Почему #1: ...)
                r"(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)[:\s]*([^\n]+)[\s\n]*(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*|^)[\s\n]*([^\n]+)",
                
                # 3. С номером и словом "вопрос" (Вопрос #1: ...)
                r"(?:вопрос|question)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)[:\s]*([^\n]+)[\s\n]*(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*|^)[\s\n]*([^\n]+)",
                
                # 4. С маркерами Markdown
                r"###[\s]*(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)[:\s]*([^\n]+)[\s\n]*(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*|^)[\s\n]*([^\n]+)",
                
                # 5. Общий паттерн для секции Корневая причина
                r"(?:корневая причина|root cause)[:\s]*([^\n]+)"
            ]
            
            # Проверяем каждый шаблон
            for pattern in patterns:
                matches = re.findall(pattern, description, re.IGNORECASE | re.MULTILINE)
                if matches:
                    # Если это шаблон для корневой причины
                    if "корневая причина" in pattern or "root cause" in pattern:
                        # Добавляем корневую причину в качестве отдельного элемента
                        for match in matches:
                            if isinstance(match, tuple):
                                match = match[0]  # Берем только первую группу
                            five_whys_list.append({
                                "type": "root_cause",
                                "content": match.strip()
                            })
                    else:
                        # Обрабатываем вопросы и ответы
                        for match in matches:
                            if isinstance(match, tuple) and len(match) >= 2:
                                question = match[0].strip()
                                answer = match[1].strip()
                                
                                # Добавляем вопрос и ответ к результату
                                five_whys_list.append({
                                    "type": "question_answer",
                                    "question": question,
                                    "answer": answer
                                })
            
            # Если не удалось извлечь вопросы и ответы, пробуем разбить на секции по маркерам Markdown
            if not five_whys_list:
                # Разбиваем текст на секции по маркерам Markdown
                sections = re.split(r"###+", description)
                for section in sections:
                    # Проверяем, содержит ли секция ключевые слова 5-почему
                    if re.search(r"(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)", section, re.IGNORECASE):
                        # Извлекаем заголовок секции и содержимое
                        section_match = re.match(r"([^\n]+)[\n\s]*(.*)", section.strip(), re.DOTALL)
                        if section_match:
                            title = section_match.group(1).strip()
                            content = section_match.group(2).strip()
                            
                            # Проверяем, является ли это вопросом или корневой причиной
                            if re.search(r"(?:корневая причина|root cause)", title, re.IGNORECASE):
                                five_whys_list.append({
                                    "type": "root_cause",
                                    "content": content
                                })
                            else:
                                # Ищем ответ в содержимом секции
                                answer_match = re.search(r"(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*)[\s\n]*([^\n]+)", content, re.IGNORECASE)
                                answer = answer_match.group(1).strip() if answer_match else content
                                
                                five_whys_list.append({
                                    "type": "question_answer",
                                    "question": title,
                                    "answer": answer
                                })
            
            # Если всё ещё нет результатов, ищем блоки текста, разделенные пустыми строками
            if not five_whys_list:
                # Разбиваем текст на блоки, разделенные пустыми строками
                blocks = re.split(r"\n\s*\n", description)
                for block in blocks:
                    block = block.strip()
                    if not block:
                        continue
                    
                    # Проверяем, содержит ли блок ключевые слова 5-почему
                    if re.search(r"(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)", block, re.IGNORECASE):
                        # Разбиваем блок на строки
                        lines = block.split("\n")
                        
                        # Ищем строки с вопросом и ответом
                        for i in range(len(lines) - 1):
                            if re.search(r"(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)", lines[i], re.IGNORECASE):
                                question = lines[i].strip()
                                answer = lines[i + 1].strip()
                                
                                # Проверяем, есть ли в ответе ключевые слова
                                if not re.search(r"(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*)", answer, re.IGNORECASE):
                                    # Если нет, проверяем, есть ли в вопросе двоеточие
                                    if ":" in question:
                                        question_parts = question.split(":", 1)
                                        question = question_parts[0].strip() + "?"
                                        if len(question_parts) > 1 and question_parts[1].strip():
                                            answer = question_parts[1].strip()
                                
                                five_whys_list.append({
                                    "type": "question_answer",
                                    "question": question,
                                    "answer": answer
                                })
                    
                    # Проверяем, содержит ли блок ключевые слова корневой причины
                    elif re.search(r"(?:корневая причина|root cause)", block, re.IGNORECASE):
                        # Разбиваем блок на строки
                        lines = block.split("\n")
                        
                        # Ищем строки с корневой причиной
                        for i in range(len(lines)):
                            if re.search(r"(?:корневая причина|root cause)", lines[i], re.IGNORECASE):
                                # Если это последняя строка или следующая строка пустая, используем текущую строку
                                if i == len(lines) - 1 or not lines[i + 1].strip():
                                    # Извлекаем корневую причину из текущей строки
                                    cause_match = re.search(r"(?:корневая причина|root cause)[:\s]*([^\n]+)", lines[i], re.IGNORECASE)
                                    if cause_match:
                                        five_whys_list.append({
                                            "type": "root_cause",
                                            "content": cause_match.group(1).strip()
                                        })
                                else:
                                    # Используем следующую строку как корневую причину
                                    five_whys_list.append({
                                        "type": "root_cause",
                                        "content": lines[i + 1].strip()
                                    })
                                break
            
            logger.info(f"Найден 5-почему анализ в описании: {len(five_whys_list)} элементов")
            return five_whys_list
        except Exception as e:
            logger.error(f"Ошибка при извлечении 5-почему анализа: {e}")
            traceback.print_exc()
            return []def _update_incident_statistics(self, title: str, properties: dict) -> dict:
        """
        Обновляет статистику по инцидентам.
        
        Args:
            title: Название инцидента
            properties: Свойства инцидента
            
        Returns:
            dict: Обновленная статистика
        """
        try:
            # Здесь будет код для обновления статистики по инцидентам
            # В реальной реализации нужно подключить соответствующий модуль
            
            # Симуляция статистики
            stats = {
                "total_incidents": 25,  # Общее количество инцидентов
                "active_incidents": 8,  # Активные инциденты
                "resolved_incidents": 17,  # Разрешенные инциденты
                "by_category": {  # Статистика по категориям
                    "bug": 10,
                    "security": 5,
                    "performance": 7,
                    "outage": 3
                },
                "by_severity": {  # Статистика по серьезности
                    "critical": 4,
                    "high": 6,
                    "medium": 10,
                    "low": 5
                }
            }
            
            # Добавляем категорию из текущего инцидента, если она есть
            category = properties.get("category", "general")
            if category in stats["by_category"]:
                stats["by_category"][category] += 1
            else:
                stats["by_category"][category] = 1
            
            # Добавляем серьезность из текущего инцидента, если она есть
            severity = properties.get("severity", "medium")
            if severity in stats["by_severity"]:
                stats["by_severity"][severity] += 1
            else:
                stats["by_severity"][severity] = 1
            
            # Увеличиваем общее количество и активные инциденты
            stats["total_incidents"] += 1
            stats["active_incidents"] += 1
            
            logger.info(f"Обновлена статистика инцидентов после добавления '{title}'")
            
            return stats
        except Exception as e:
            logger.error(f"Ошибка при обновлении статистики инцидентов: {e}")
            return {}
    
    def _check_related_incidents(self, title: str, description: str) -> list:
        """
        Проверяет наличие связанных инцидентов.
        
        Args:
            title: Название инцидента
            description: Описание инцидента
            
        Returns:
            list: Список связанных инцидентов
        """
        try:
            # Здесь будет код для проверки связанных инцидентов
            # В реальной реализации нужно подключить соответствующий модуль
            
            # Для демонстрации предположим, что связанных инцидентов нет
            related_incidents = []
            
            return related_incidents
        except Exception as e:
            logger.error(f"Ошибка при проверке связанных инцидентов: {e}")
            return []
    
    def _handle_incident_update(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер обновления инцидента.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Реализация обработки триггера обновления инцидента
        return TriggerResult(success=True, message="Инцидент обновлен")
    
    def _handle_hypothesis_create(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер создания гипотезы.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        try:
            # Извлекаем данные из контекста
            title = context.data.get("title", "Без названия")
            description = context.data.get("description", "")
            file_path = context.data.get("file_path", "")
            properties = context.data.get("properties", {})
            
            # Получаем RAT и критерий фальсифицируемости из контекста или из описания
            rat = context.data.get("rat", "")
            falsifiability_criterion = context.data.get("falsifiability_criterion", "")
            
            # Если RAT или критерий фальсифицируемости не переданы в контексте, 
            # пытаемся извлечь их из описания
            components = self._extract_hypothesis_components(description)
            if not rat:
                rat = components.get("rat", "")
            if not falsifiability_criterion:
                falsifiability_criterion = components.get("falsifiability_criterion", "")
            
            # 1. Верификация гипотезы
            hypothesis_verification = self._verify_hypothesis(description, rat, falsifiability_criterion)
            logger.info(f"Верификация гипотезы: {hypothesis_verification}")
            
            # 2. Отправка отчета через report_progress
            if self.report_progress:
                # Формируем текст отчета
                report_text = f"# Гипотеза: {title}\n\n"
                report_text += f"## Описание\n{description}\n\n"
                
                if rat:
                    report_text += f"## Рисуемая мишень (RAT)\n{rat}\n\n"
                
                if falsifiability_criterion:
                    report_text += f"## Критерий фальсифицируемости\n{falsifiability_criterion}\n\n"
                
                # Отправляем полный отчет о гипотезе
                self.report_progress({
                    "type": "hypothesis_created",
                    "title": f"Создана новая гипотеза: '{title}'",
                    "hypothesis": {
                        "title": title,
                        "description": description,
                        "rat": rat,
                        "falsifiability_criterion": falsifiability_criterion,
                        "file_path": file_path
                    },
                    "text": report_text,
                    "message": f"Создана новая гипотеза: '{title}'"
                })
                
                # Отправляем отчет о верификации гипотезы
                verification_text = f"# Верификация гипотезы: '{title}'\n\n"
                
                # Добавляем оценку компонентов
                verification_text += "## Компоненты гипотезы\n"
                has_rat = hypothesis_verification.get("has_rat", False)
                has_falsifiability = hypothesis_verification.get("has_falsifiability", False)
                has_experiment = hypothesis_verification.get("has_experiment", False)
                
                verification_text += f"- Рисуемая мишень (RAT): {'✅ Присутствует' if has_rat else '❌ Отсутствует'}\n"
                verification_text += f"- Критерий фальсифицируемости: {'✅ Присутствует' if has_falsifiability else '❌ Отсутствует'}\n"
                verification_text += f"- План проверки: {'✅ Присутствует' if has_experiment else '❌ Отсутствует'}\n\n"
                
                # Отправляем отчет о верификации
                self.report_progress({
                    "type": "hypothesis_verification",
                    "title": f"Верификация гипотезы '{title}'",
                    "verification": hypothesis_verification,
                    "text": verification_text,
                    "message": "Проверка компонентов гипотезы"
                })
                
                # Если есть проблемы с верификацией, выводим предупреждение
                issues = hypothesis_verification.get("issues", [])
                if issues:
                    issues_text = f"# Проблемы в гипотезе '{title}'\n\n"
                    for i, issue in enumerate(issues):
                        issues_text += f"{i+1}. {issue}\n"
                    
                    self.report_progress({
                        "type": "hypothesis_verification_warning",
                        "title": title,
                        "issues": issues,
                        "text": issues_text,
                        "message": f"Внимание! Обнаружены проблемы с гипотезой '{title}'"
                    })
            
            return TriggerResult(
                success=True,
                message=f"Гипотеза '{title}' успешно создана и обработана",
                data={
                    "hypothesis_id": file_path,
                    "verification": hypothesis_verification,
                    "rat": rat,
                    "falsifiability_criterion": falsifiability_criterion
                }
            )
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера создания гипотезы: {e}")
            traceback.print_exc()
            
            return TriggerResult(success=False, message=f"Ошибка при обработке триггера создания гипотезы: {e}")
    
    def _extract_hypothesis_components(self, description: str) -> dict:
        """
        Извлекает компоненты гипотезы из её описания.
        
        Args:
            description: Описание гипотезы
            
        Returns:
            dict: Словарь с компонентами гипотезы
        """
        try:
            components = {
                "hypothesis_text": "",
                "rat": "",
                "falsifiability_criterion": "",
                "experiment_plan": "",
                "metrics": ""
            }
            
            # Извлекаем формулировку гипотезы
            hypothesis_patterns = [
                r"## Гипотеза",
                r"## Формулировка гипотезы",
                r"## Описание гипотезы",
                r"## Hypothesis"
            ]
            
            for pattern in hypothesis_patterns:
                match = re.search(pattern + r"\s*\n+(.+?)(?=\n\s*##|\Z)", description, re.IGNORECASE | re.DOTALL)
                if match:
                    components["hypothesis_text"] = match.group(1).strip()
                    break
            
            # Извлекаем RAT (Рисуемая мишень)
            rat_patterns = [
                r"## RAT",
                r"## Рисуемая мишень",
                r"## Rapid Assumption Testing"
            ]
            
            for pattern in rat_patterns:
                match = re.search(pattern + r"\s*\n+(.+?)(?=\n\s*##|\Z)", description, re.IGNORECASE | re.DOTALL)
                if match:
                    components["rat"] = match.group(1).strip()
                    break
            
            # Извлекаем критерий фальсифицируемости
            falsifiability_patterns = [
                r"## Критерий фальсифицируемости",
                r"## Фальсифицируемость",
                r"## Falsifiability",
                r"## Falsification criterion"
            ]
            
            for pattern in falsifiability_patterns:
                match = re.search(pattern + r"\s*\n+(.+?)(?=\n\s*##|\Z)", description, re.IGNORECASE | re.DOTALL)
                if match:
                    components["falsifiability_criterion"] = match.group(1).strip()
                    break
            
            # Извлекаем план эксперимента
            experiment_patterns = [
                r"## План эксперимента",
                r"## План проверки",
                r"## Experiment plan",
                r"## Verification plan"
            ]
            
            for pattern in experiment_patterns:
                match = re.search(pattern + r"\s*\n+(.+?)(?=\n\s*##|\Z)", description, re.IGNORECASE | re.DOTALL)
                if match:
                    components["experiment_plan"] = match.group(1).strip()
                    break
            
            # Извлекаем метрики
            metrics_patterns = [
                r"## Метрики",
                r"## Metrics",
                r"## Показатели"
            ]
            
            for pattern in metrics_patterns:
                match = re.search(pattern + r"\s*\n+(.+?)(?=\n\s*##|\Z)", description, re.IGNORECASE | re.DOTALL)
                if match:
                    components["metrics"] = match.group(1).strip()
                    break
            
            return components
        except Exception as e:
            logger.error(f"Ошибка при извлечении компонентов гипотезы: {e}")
            traceback.print_exc()
            return {}
    
    def _verify_hypothesis(self, description: str, rat: str = "", falsifiability_criterion: str = "") -> dict:
        """
        Верифицирует гипотезу на наличие всех необходимых компонентов.
        
        Args:
            description: Описание гипотезы
            rat: Рисуемая мишень (Rapid Assumption Testing), если уже извлечена
            falsifiability_criterion: Критерий фальсифицируемости, если уже извлечен
            
        Returns:
            dict: Результаты верификации
        """
        try:
            verification_result = {
                "has_hypothesis": False,
                "has_rat": False,  # Rapid Assumption Testing
                "has_falsifiability": False,
                "has_experiment": False,
                "has_metrics": False,
                "issues": [],
                "components": {}
            }
            
            # Проверяем наличие формулировки гипотезы
            hypothesis_patterns = [
                r"## Гипотеза",
                r"## Формулировка гипотезы",
                r"## Описание гипотезы",
                r"## Hypothesis"
            ]
            
            for pattern in hypothesis_patterns:
                if re.search(pattern, description, re.IGNORECASE):
                    verification_result["has_hypothesis"] = True
                    
                    # Извлекаем текст гипотезы
                    match = re.search(pattern + r"\s*\n+(.+?)(?=\n\s*##|\Z)", description, re.IGNORECASE | re.DOTALL)
                    if match:
                        verification_result["components"]["hypothesis"] = match.group(1).strip()
                    break
            
            # Проверяем наличие RAT (Rapid Assumption Testing)
            # Сначала проверяем переданный параметр rat
            if rat:
                verification_result["has_rat"] = True
                verification_result["components"]["rat"] = rat
            else:
                # Если параметр не передан, ищем в описании
                rat_patterns = [
                    r"## RAT",
                    r"## Быстрая проверка предположений",
                    r"## Рисуемая мишень",
                    r"## Rapid Assumption Testing"
                ]
                
                for pattern in rat_patterns:
                    if re.search(pattern, description, re.IGNORECASE):
                        verification_result["has_rat"] = True
                        
                        # Извлекаем текст RAT
                        match = re.search(pattern + r"\s*\n+(.+?)(?=\n\s*##|\Z)", description, re.IGNORECASE | re.DOTALL)
                        if match:
                            verification_result["components"]["rat"] = match.group(1).strip()
                        break
            
            # Проверяем наличие критерия фальсифицируемости
            # Сначала проверяем переданный параметр falsifiability_criterion
            if falsifiability_criterion:
                verification_result["has_falsifiability"] = True
                verification_result["components"]["falsifiability"] = falsifiability_criterion
            else:
                # Если параметр не передан, ищем в описании
                falsifiability_patterns = [
                    r"## Фальсифицируемость",
                    r"## Критерий фальсифицируемости",
                    r"## Falsifiability",
                    r"## Falsification criterion"
                ]
                
                for pattern in falsifiability_patterns:
                    if re.search(pattern, description, re.IGNORECASE):
                        verification_result["has_falsifiability"] = True
                        
                        # Извлекаем текст критерия фальсифицируемости
                        match = re.search(pattern + r"\s*\n+(.+?)(?=\n\s*##|\Z)", description, re.IGNORECASE | re.DOTALL)
                        if match:
                            verification_result["components"]["falsifiability"] = match.group(1).strip()
                        break
            
            # Проверяем наличие описания эксперимента
            experiment_patterns = [
                r"## Эксперимент",
                r"## Описание эксперимента",
                r"## Experiment"
            ]
            
            for pattern in experiment_patterns:
                if re.search(pattern, description, re.IGNORECASE):
                    verification_result["has_experiment"] = True
                    
                    # Извлекаем текст описания эксперимента
                    match = re.search(pattern + r"\s*\n+(.+?)(?=\n\s*##|\Z)", description, re.IGNORECASE | re.DOTALL)
                    if match:
                        verification_result["components"]["experiment"] = match.group(1).strip()
                    break
            
            # Проверяем наличие метрик для оценки результатов
            metrics_patterns = [
                r"## Метрики",
                r"## Критерии оценки",
                r"## Metrics"
            ]
            
            for pattern in metrics_patterns:
                if re.search(pattern, description, re.IGNORECASE):
                    verification_result["has_metrics"] = True
                    
                    # Извлекаем текст метрик
                    match = re.search(pattern + r"\s*\n+(.+?)(?=\n\s*##|\Z)", description, re.IGNORECASE | re.DOTALL)
                    if match:
                        verification_result["components"]["metrics"] = match.group(1).strip()
                    break
            
            # Формируем список проблем
            if not verification_result["has_hypothesis"]:
                verification_result["issues"].append("Отсутствует формулировка гипотезы")
            
            if not verification_result["has_rat"]:
                verification_result["issues"].append("Отсутствует RAT (быстрая проверка предположений)")
            
            if not verification_result["has_falsifiability"]:
                verification_result["issues"].append("Отсутствует критерий фальсифицируемости")
            
            if not verification_result["has_experiment"]:
                verification_result["issues"].append("Отсутствует описание эксперимента")
            
            if not verification_result["has_metrics"]:
                verification_result["issues"].append("Отсутствуют метрики для оценки результатов")
            
            return verification_result
        except Exception as e:
            logger.error(f"Ошибка при верификации гипотезы: {e}")
            return {"has_hypothesis": False, "has_rat": False, "has_falsifiability": False, 
                    "has_experiment": False, "has_metrics": False, "issues": ["Ошибка при верификации гипотезы"], "components": {}}
    
    def _handle_hypothesis_update(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер обновления гипотезы.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Реализация обработки триггера обновления гипотезы
        return TriggerResult(success=True, message="Гипотеза обновлена")
    
    def _standardize_standard_format(self, description: str, properties: Dict[str, Any]) -> Tuple[str, Dict[str, Any]]:
        """
        Стандартизирует формат стандарта.
        
        Args:
            description: Описание стандарта
            properties: Свойства стандарта
            
        Returns:
            Tuple[str, Dict[str, Any]]: Стандартизированные описание и свойства
        """
        try:
            # Проверяем и обновляем свойства стандарта
            if "status" not in properties or not properties["status"]:
                properties["status"] = "Active"
            
            if "version" not in properties or not properties["version"]:
                properties["version"] = "1.0"
            
            if "tags" not in properties or not properties["tags"]:
                properties["tags"] = ["standard"]
            
            if "updated" not in properties or not properties["updated"]:
                properties["updated"] = datetime.now().strftime("%d %B %Y, %H:%M CET")
            
            # Проверяем наличие защищенной секции
            protected_section_start = "<!-- 🔒 PROTECTED SECTION: BEGIN -->"
            protected_section_end = "<!-- 🔒 PROTECTED SECTION: END -->"
            
            if protected_section_start not in description and protected_section_end not in description:
                # Создаем защищенную секцию с метаданными
                protected_section = f"{protected_section_start}\ntype: standard\nversion: {properties['version']}\nstatus: {properties['status']}\nupdated: {properties['updated']}\ntags: {', '.join(properties['tags'])}\n{protected_section_end}\n\n"
                
                # Добавляем защищенную секцию в начало описания
                description = protected_section + description
            
            # Проверяем наличие заголовка
            if not re.search(r"^#\s", description, re.MULTILINE):
                # Получаем название стандарта
                title = properties.get("title", "Стандарт")
                
                # Добавляем заголовок после защищенной секции
                pattern = f"{protected_section_end}\n"
                replacement = f"{protected_section_end}\n\n# {title}\n\n"
                description = re.sub(pattern, replacement, description)
            
            # Проверяем наличие метаданных
            metadata_pattern = r"\*\*Версия:\*\*|\*\*Статус:\*\*|\*\*Дата создания:\*\*|\*\*Автор:\*\*"
            if not re.search(metadata_pattern, description, re.MULTILINE):
                # Получаем метаданные
                version = properties.get("version", "1.0")
                status = properties.get("status", "Active")
                date = datetime.now().strftime("%d %B %Y")
                author = properties.get("author", "AI Assistant")
                
                # Создаем блок метаданных
                metadata_block = f"**Версия:** {version}  \n**Статус:** {status}  \n**Дата создания:** {date}  \n**Автор:** {author}  \n"
                
                # Добавляем блок метаданных после заголовка
                pattern = r"^#\s.*$"
                match = re.search(pattern, description, re.MULTILINE)
                if match:
                    header_end = match.end()
                    description = description[:header_end] + "\n\n" + metadata_block + description[header_end:]
            
            # Проверяем наличие разделов
            sections = ["Цель документа", "Зачем нужен этот стандарт", "Критерии качества"]
            for section in sections:
                section_pattern = f"##\s.*{section}"
                if not re.search(section_pattern, description, re.MULTILINE):
                    # Добавляем отсутствующие разделы в конец документа
                    description += f"\n\n## {section}\n\n*Раздел требует заполнения*\n"
            
            return description, properties
        except Exception as e:
            logger.error(f"Ошибка при стандартизации формата стандарта: {e}")
            traceback.print_exc()
            return description, properties

    def _handle_standard_create(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер создания стандарта.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        try:
            # Извлекаем данные из контекста
            title = context.data.get("title", "Без названия")
            description = context.data.get("description", "")
            file_path = context.data.get("file_path", "")
            properties = context.data.get("properties", {})
            
            # 1. Проверка на близкие или зависимые стандарты
            related_standards = self._check_related_standards(title, description)
            
            # 2. Проверка на соответствие требованиям мини-манифеста
            standards_verification = self._verify_standard_format(description)
            
            # 3. Отправка отчета через report_progress
            if self.report_progress:
                # Формируем текст отчета о стандарте
                standard_text = f"# Стандарт: {title}\n\n"
                standard_text += f"## Описание\n{description}\n\n"
                
                if properties.get("version"):
                    standard_text += f"## Версия\n{properties.get('version')}\n\n"
                
                if properties.get("author"):
                    standard_text += f"## Автор\n{properties.get('author')}\n\n"
                
                if properties.get("tags"):
                    standard_text += f"## Теги\n" + "\n".join([f"- {tag}" for tag in properties.get("tags", [])]) + "\n\n"
                
                # Отправляем информацию о новом стандарте
                self.report_progress({
                    "type": "standard_created",
                    "title": f"Создан новый стандарт: '{title}'",
                    "standard": {
                        "title": title,
                        "description": description,
                        "file_path": file_path,
                        "properties": properties
                    },
                    "text": standard_text,
                    "message": f"Создан новый стандарт: '{title}'"
                })
                
                # Отчет о результатах верификации стандарта
                verification_text = f"# Верификация стандарта: '{title}'\n\n"
                
                # Добавляем оценку компонентов
                if standards_verification.get("sections"):
                    verification_text += "## Компоненты стандарта\n"
                    sections = standards_verification.get("sections", {})
                    for section_name, present in sections.items():
                        verification_text += f"- {section_name}: {'✅ Присутствует' if present else '❌ Отсутствует'}\n"
                    verification_text += "\n"
                
                self.report_progress({
                    "type": "standard_verification",
                    "title": f"Верификация стандарта '{title}'",
                    "verification": standards_verification,
                    "text": verification_text,
                    "message": "Проверка формата стандарта"
                })
                
                # Если есть проблемы с форматом стандарта, выводим предупреждение
                issues = standards_verification.get("issues", [])
                if issues:
                    issues_text = f"# Проблемы в стандарте '{title}'\n\n"
                    for i, issue in enumerate(issues):
                        issues_text += f"{i+1}. {issue}\n"
                    
                    self.report_progress({
                        "type": "standard_format_warning",
                        "title": title,
                        "issues": issues,
                        "text": issues_text,
                        "message": f"Внимание! Обнаружены проблемы с форматом стандарта '{title}'"
                    })
                
                # Если есть близкие стандарты, выводим информацию о них
                if related_standards:
                    related_text = f"# Близкие стандарты для '{title}'\n\n"
                    for i, std in enumerate(related_standards):
                        related_text += f"{i+1}. **{std.get('title', 'Без названия')}**\n"
                        related_text += f"   - Путь: {std.get('file_path', 'Неизвестно')}\n"
                        related_text += f"   - Похожесть: {std.get('similarity', 0):.2f}%\n\n"
                    
                    self.report_progress({
                        "type": "standard_related_warning",
                        "title": title,
                        "related_standards": related_standards,
                        "text": related_text,
                        "message": f"Внимание! Обнаружены похожие стандарты для '{title}'"
                    })
            
            # Предотвращаем создание стандарта, если есть очень похожие
            if any(standard.get("similarity", 0) > 0.85 for standard in related_standards):
                return TriggerResult(
                    success=False,
                    message=f"Стандарт '{title}' не создан: обнаружен очень похожий стандарт",
                    data={
                        "related_standards": related_standards,
                        "verification": standards_verification
                    }
                )
            
            return TriggerResult(
                success=True,
                message=f"Стандарт '{title}' успешно создан и обработан",
                data={
                    "standard_id": file_path,
                    "related_standards": related_standards,
                    "verification": standards_verification
                }
            )
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера создания стандарта: {e}")
            traceback.print_exc()
            
            return TriggerResult(success=False, message=f"Ошибка при обработке триггера создания стандарта: {e}")
    
    def _check_related_standards(self, title: str, description: str) -> list:
        """
        Проверяет наличие близких или зависимых стандартов.
        
        Args:
            title: Название стандарта
            description: Описание стандарта
            
        Returns:
            list: Список близких или зависимых стандартов
        """
        try:
            # Здесь будет код для проверки близких или зависимых стандартов
            # В реальной реализации нужно подключить соответствующий модуль
            
            # Для демонстрации предположим, что близких стандартов нет
            related_standards = []
            
            return related_standards
        except Exception as e:
            logger.error(f"Ошибка при проверке близких стандартов: {e}")
            return []
    
    def _verify_standard_format(self, description: str) -> dict:
        """
        Проверяет соответствие стандарта требованиям мини-манифеста.
        
        Args:
            description: Описание стандарта
            
        Returns:
            dict: Результаты верификации
        """
        try:
            verification_result = {
                "has_title": False,
                "has_purpose": False,
                "has_criteria": False,
                "has_examples": False,
                "has_relations": False,
                "issues": [],
                "components": {}
            }
            
            # Проверяем наличие заголовка
            title_patterns = [
                r"# [^\n]+",
                r"^[^\n]+"  # Первая непустая строка
            ]
            
            for pattern in title_patterns:
                match = re.search(pattern, description)
                if match:
                    verification_result["has_title"] = True
                    verification_result["components"]["title"] = match.group(0).strip("#").strip()
                    break
            
            # Проверяем наличие назначения/цели
            purpose_patterns = [
                r"## Назначение",
                r"## Цель",
                r"## Purpose"
            ]
            
            for pattern in purpose_patterns:
                if re.search(pattern, description, re.IGNORECASE):
                    verification_result["has_purpose"] = True
                    
                    # Извлекаем текст назначения
                    match = re.search(pattern + r"\s*\n+(.+?)(?=\n\s*##|\Z)", description, re.IGNORECASE | re.DOTALL)
                    if match:
                        verification_result["components"]["purpose"] = match.group(1).strip()
                    break
            
            # Проверяем наличие критериев
            criteria_patterns = [
                r"## Критерии",
                r"## Критерии соответствия",
                r"## Criteria"
            ]
            
            for pattern in criteria_patterns:
                if re.search(pattern, description, re.IGNORECASE):
                    verification_result["has_criteria"] = True
                    
                    # Извлекаем текст критериев
                    match = re.search(pattern + r"\s*\n+(.+?)(?=\n\s*##|\Z)", description, re.IGNORECASE | re.DOTALL)
                    if match:
                        verification_result["components"]["criteria"] = match.group(1).strip()
                    break
            
            # Проверяем наличие примеров
            examples_patterns = [
                r"## Примеры",
                r"## Примеры использования",
                r"## Examples"
            ]
            
            for pattern in examples_patterns:
                if re.search(pattern, description, re.IGNORECASE):
                    verification_result["has_examples"] = True
                    
                    # Извлекаем текст примеров
                    match = re.search(pattern + r"\s*\n+(.+?)(?=\n\s*##|\Z)", description, re.IGNORECASE | re.DOTALL)
                    if match:
                        verification_result["components"]["examples"] = match.group(1).strip()
                    break
            
            # Проверяем наличие связей
            relations_patterns = [
                r"## Связи",
                r"## Связанные стандарты",
                r"## Relations"
            ]
            
            for pattern in relations_patterns:
                if re.search(pattern, description, re.IGNORECASE):
                    verification_result["has_relations"] = True
                    
                    # Извлекаем текст связей
                    match = re.search(pattern + r"\s*\n+(.+?)(?=\n\s*##|\Z)", description, re.IGNORECASE | re.DOTALL)
                    if match:
                        verification_result["components"]["relations"] = match.group(1).strip()
                    break
            
            # Формируем список проблем
            if not verification_result["has_title"]:
                verification_result["issues"].append("Отсутствует заголовок стандарта")
            
            if not verification_result["has_purpose"]:
                verification_result["issues"].append("Отсутствует раздел назначения/цели")
            
            if not verification_result["has_criteria"]:
                verification_result["issues"].append("Отсутствует раздел критериев соответствия")
            
            if not verification_result["has_examples"]:
                verification_result["issues"].append("Отсутствует раздел примеров")
            
            if not verification_result["has_relations"]:
                verification_result["issues"].append("Отсутствует раздел связей с другими стандартами")
            
            return verification_result
        except Exception as e:
            logger.error(f"Ошибка при верификации формата стандарта: {e}")
            return {"has_title": False, "has_purpose": False, "has_criteria": False, 
                    "has_examples": False, "has_relations": False, 
                    "issues": ["Ошибка при верификации формата стандарта"], "components": {}}
    
    def _handle_standard_update(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер обновления стандарта.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Реализация обработки триггера обновления стандарта
        return TriggerResult(success=True, message="Стандарт обновлен")
    
    def _handle_cache_sync(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер синхронизации кеша.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        try:
            # Извлекаем данные из контекста
            sync_data = context.data.get("sync_data", {})
            updated_files = sync_data.get("updated_files", [])
            created_files = sync_data.get("created_files", [])
            deleted_files = sync_data.get("deleted_files", [])
            
            # Проверяем новые или обновленные скрипты на наличие дублирующегося кода
            all_checked_files = []
            
            # Проверяем созданные файлы
            for file_path in created_files:
                if self._is_script_file(file_path):
                    all_checked_files.append(file_path)
            
            # Проверяем обновленные файлы
            for file_path in updated_files:
                if self._is_script_file(file_path):
                    all_checked_files.append(file_path)
            
            # Если есть скрипты для проверки, проверяем их на дублирование кода
            code_duplications = []
            if all_checked_files:
                code_duplications = self._check_code_duplications(all_checked_files)
                
                # Если найдены дубликаты, выводим предупреждение
                if code_duplications and self.report_progress:
                    self.report_progress({
                        "type": "code_duplication_warning",
                        "title": "Обнаружено дублирование кода",
                        "duplications": code_duplications,
                        "message": "Внимание! Обнаружено дублирование кода в скриптах"
                    })
            
            return TriggerResult(
                success=True,
                message="Кеш синхронизирован и проверен на дублирование кода",
                data={
                    "updated_files": updated_files,
                    "created_files": created_files,
                    "deleted_files": deleted_files,
                    "code_duplications": code_duplications
                }
            )
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера синхронизации кеша: {e}")
            traceback.print_exc()
            
            return TriggerResult(success=False, message=f"Ошибка при обработке триггера синхронизации кеша: {e}")
    
    def _is_script_file(self, file_path: str) -> bool:
        """
        Проверяет, является ли файл скриптом.
        
        Args:
            file_path: Путь к файлу
            
        Returns:
            bool: True, если файл является скриптом, иначе False
        """
        try:
            # Проверяем расширение файла
            script_extensions = ['.py', '.js', '.ts', '.sh']
            for ext in script_extensions:
                if file_path.endswith(ext):
                    return True
            
            # Проверяем наличие шебанга в начале файла
            if os.path.exists(file_path) and os.path.isfile(file_path):
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        first_line = f.readline().strip()
                        if first_line.startswith('#!') and ('python' in first_line or 'bash' in first_line or 'node' in first_line):
                            return True
                except:
                    pass
            
            return False
        except Exception as e:
            logger.error(f"Ошибка при проверке скрипта {file_path}: {e}")
            return False
    
    def _check_code_duplications(self, file_paths: list) -> list:
        """
        Проверяет наличие дублирующегося кода в файлах.
        
        Args:
            file_paths: Список путей к файлам для проверки
            
        Returns:
            list: Список найденных дубликатов кода
        """
        try:
            duplications = []
            
            # Загружаем содержимое файлов
            file_contents = {}
            for file_path in file_paths:
                try:
                    with open(file_path, 'r', encoding='utf-8') as f:
                        content = f.read()
                        file_contents[file_path] = content
                except Exception as e:
                    logger.error(f"Ошибка при чтении файла {file_path}: {e}")
            
            # Проверяем файлы на дублирование кода
            processed_pairs = set()
            for file_path1, content1 in file_contents.items():
                for file_path2, content2 in file_contents.items():
                    # Не сравниваем файл с самим собой и проверяем, что эта пара файлов еще не была обработана
                    if file_path1 != file_path2 and (file_path1, file_path2) not in processed_pairs and (file_path2, file_path1) not in processed_pairs:
                        processed_pairs.add((file_path1, file_path2))
                        
                        duplication = self._find_duplication_between_files(file_path1, content1, file_path2, content2)
                        if duplication:
                            duplications.append(duplication)
            
            return duplications
        except Exception as e:
            logger.error(f"Ошибка при проверке дублирования кода: {e}")
            return []
    
    def _find_duplication_between_files(self, file_path1: str, content1: str, file_path2: str, content2: str) -> dict:
        """
        Находит дублирующийся код между двумя файлами.
        
        Args:
            file_path1: Путь к первому файлу
            content1: Содержимое первого файла
            file_path2: Путь ко второму файлу
            content2: Содержимое второго файла
            
        Returns:
            dict: Информация о найденных дубликатах или None, если дубликатов нет
        """
        try:
            # Разбиваем содержимое файлов на строки
            lines1 = content1.split('\n')
            lines2 = content2.split('\n')
            
            # Определяем минимальное количество строк, которые считаются дубликатом
            min_duplicate_lines = 5
            
            # Ищем дубликаты строк
            duplications = []
            i = 0
            while i < len(lines1):
                j = 0
                while j < len(lines2):
                    # Если нашли совпадающую строку, проверяем, может быть это начало дубликата
                    if lines1[i].strip() == lines2[j].strip() and len(lines1[i].strip()) > 10:  # Пропускаем короткие строки
                        # Считаем, сколько последовательных строк совпадает
                        duplicate_lines_count = 1
                        while (i + duplicate_lines_count < len(lines1) and 
                               j + duplicate_lines_count < len(lines2) and 
                               lines1[i + duplicate_lines_count].strip() == lines2[j + duplicate_lines_count].strip()):
                            duplicate_lines_count += 1
                        
                        # Если нашли достаточно длинный дубликат
                        if duplicate_lines_count >= min_duplicate_lines:
                            duplicate_content = '\n'.join(lines1[i:i+duplicate_lines_count])
                            
                            # Добавляем информацию о дубликате
                            duplications.append({
                                'file1': file_path1,
                                'line1': i + 1,  # Номер строки начинается с 1
                                'file2': file_path2,
                                'line2': j + 1,  # Номер строки начинается с 1
                                'length': duplicate_lines_count,
                                'content': duplicate_content
                            })
                            
                            # Пропускаем дублирующиеся строки, чтобы не находить их повторно
                            i += duplicate_lines_count - 1
                            j += duplicate_lines_count - 1
                    j += 1
                i += 1
            
            # Если нашли хотя бы один дубликат, возвращаем информацию
            if duplications:
                return {
                    'file1': file_path1,
                    'file2': file_path2,
                    'duplications': duplications
                }
            
            return None
        except Exception as e:
            logger.error(f"Ошибка при поиске дубликатов между файлами {file_path1} и {file_path2}: {e}")
            return None
    
    def _calculate_similarity(self, text1: str, text2: str) -> float:
        """
        Вычисляет процент схожести двух текстовых блоков.
        
        Args:
            text1: Первый текстовый блок
            text2: Второй текстовый блок
            
        Returns:
            float: Процент схожести (0-100)
        """
        try:
            if not text1 or not text2:
                return 0.0
                
            # Простой алгоритм: используем отношение длины наибольшей общей подпоследовательности
            # к средней длине двух текстов
            lines1 = text1.split("\n")
            lines2 = text2.split("\n")
            
            # Считаем количество совпадающих строк
            matching_lines = sum(1 for l1, l2 in zip(lines1, lines2) if l1.strip() == l2.strip())
            
            # Вычисляем процент схожести
            avg_length = (len(lines1) + len(lines2)) / 2
            if avg_length == 0:
                return 0.0
                
            similarity = (matching_lines / avg_length) * 100
            
            return similarity
        except Exception as e:
            logger.error(f"Ошибка при вычислении схожести текстовых блоков: {e}")
            return 0.0
    
    def _extend_matching_block(self, lines1: list, lines2: list, start1: int, start2: int, initial_size: int) -> tuple:
        """
        Расширяет найденный совпадающий блок в обе стороны.
        
        Args:
            lines1: Строки первого файла
            lines2: Строки второго файла
            start1: Начальная позиция в первом файле
            start2: Начальная позиция во втором файле
            initial_size: Исходный размер совпадающего блока
            
        Returns:
            tuple: (расширенный блок 1, расширенный блок 2, процент схожести)
        """
        try:
            # Инициализируем с исходным блоком
            end1 = start1 + initial_size
            end2 = start2 + initial_size
            
            # Расширяем вверх (к началу файла)
            while start1 > 0 and start2 > 0:
                if lines1[start1-1].strip() == lines2[start2-1].strip():
                    start1 -= 1
                    start2 -= 1
                else:
                    break
            
            # Расширяем вниз (к концу файла)
            while end1 < len(lines1) and end2 < len(lines2):
                if lines1[end1].strip() == lines2[end2].strip():
                    end1 += 1
                    end2 += 1
                else:
                    break
            
            # Извлекаем расширенные блоки
            extended_block1 = lines1[start1:end1]
            extended_block2 = lines2[start2:end2]
            
            # Вычисляем схожесть расширенных блоков
            similarity = self._calculate_similarity("\n".join(extended_block1), "\n".join(extended_block2))
            
            return extended_block1, extended_block2, similarity
        except Exception as e:
            logger.error(f"Ошибка при расширении совпадающего блока: {e}")
            # Возвращаем исходные блоки
            block1 = lines1[start1:start1+initial_size]
            block2 = lines2[start2:start2+initial_size]
            return block1, block2, 0.0
            
    def _handle_periodic_check(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер периодической проверки.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        try:
            # Получаем тип проверки
            check_type = context.data.get("check_type", "")
            
            if check_type == "code_duplication":
                # Проверка дублирования кода
                file_paths = context.data.get("file_paths", [])
                if not file_paths:
                    return TriggerResult(success=False, message="Не указаны пути к файлам для проверки дублирования кода")
                
                # Проверяем дублирование кода
                duplications = self._check_code_duplications(file_paths)
                
                # Если найдены дубликаты кода, выводим отчет
                if duplications and self.report_progress:
                    report_text = "# Результаты проверки дублирования кода\n\n"
                    
                    if duplications:
                        report_text += f"Найдено {len(duplications)} случаев дублирования кода:\n\n"
                        
                        for i, duplication in enumerate(duplications):
                            report_text += f"## Дублирование #{i+1}\n"
                            report_text += f"**Файл 1:** {duplication.get('file1', '')}\n"
                            report_text += f"**Файл 2:** {duplication.get('file2', '')}\n"
                            report_text += f"**Похожесть:** {duplication.get('similarity', 0):.2f}%\n"
                            report_text += f"**Дублированный фрагмент:**\n```python\n{duplication.get('fragment', '')}\n```\n\n"
                    else:
                        report_text += "Дублирования кода не обнаружено.\n"
                    
                    # Отправляем отчет
                    self.report_progress({
                        "type": "code_duplication_report",
                        "title": "Отчет о дублировании кода",
                        "text": report_text,
                        "duplications": duplications,
                        "message": f"Проверка дублирования кода: найдено {len(duplications)} случаев дублирования"
                    })
                
                return TriggerResult(
                    success=True,
                    message=f"Проверка дублирования кода выполнена: найдено {len(duplications)} случаев дублирования",
                    data={"duplications": duplications}
                )
            else:
                # Другие типы периодических проверок
                return TriggerResult(success=True, message=f"Периодическая проверка типа {check_type} выполнена")
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера периодической проверки: {e}")
            traceback.print_exc()
            
            return TriggerResult(success=False, message=f"Ошибка при обработке триггера периодической проверки: {e}")

# Глобальный экземпляр обработчика триггеров
_handler_instance = None

def get_handler(report_progress_func: Optional[Callable] = None) -> TriggerHandler:
    """
    Возвращает экземпляр обработчика триггеров (синглтон).
    
    Args:
        report_progress_func: Функция для отчета о прогрессе
        
    Returns:
        TriggerHandler: Экземпляр обработчика триггеров
    """
    global _handler_instance
    
    if _handler_instance is None:
        _handler_instance = TriggerHandler(report_progress_func)
    
    return _handler_instance

def get_trigger_handler_instance(report_progress_func: Optional[Callable] = None) -> TriggerHandler:
    """
    Возвращает экземпляр обработчика триггеров для совместимости.
    Обертка вокруг функции get_handler.
    
    Args:
        report_progress_func: Функция для отчета о прогрессе
        
    Returns:
        TriggerHandler: Экземпляр обработчика триггеров
    """
    return get_handler(report_progress_func)
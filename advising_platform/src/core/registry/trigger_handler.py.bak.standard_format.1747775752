"""
Модуль обработчика триггеров для задач и инцидентов.
Предоставляет единый интерфейс для обработки различных типов триггеров.
"""

import logging
import traceback
import os
import re
import json
import time
import hashlib
from typing import Any, Dict, List, Optional, Tuple, Callable
from datetime import datetime, timedelta

# Настраиваем логирование
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class TriggerType:
    """Типы триггеров."""
    TASK_CREATE = "task_create"  
    TASK_UPDATE = "task_update"  
    INCIDENT_CREATE = "incident_create"  
    INCIDENT_UPDATE = "incident_update"  
    HYPOTHESIS_CREATE = "hypothesis_create"  
    HYPOTHESIS_UPDATE = "hypothesis_update"  
    STANDARD_CREATE = "standard_create"  
    STANDARD_UPDATE = "standard_update"  
    CACHE_SYNC = "cache_sync"  
    PERIODIC_CHECK = "periodic_check"
    FILE_DUPLICATION_CHECK = "file_duplication_check"

class TriggerResult:
    """Результат обработки триггера."""
    def __init__(self, success: bool = False, message: str = "", data: Optional[Dict[str, Any]] = None):
        self.success = success
        self.message = message
        self.data = data or {}
        
    def __str__(self) -> str:
        return f"TriggerResult(success={self.success}, message={self.message}, data={self.data})"

class TriggerContext:
    """Контекст триггера."""
    def __init__(self, trigger_type: Any, data: Dict[str, Any], timestamp: Optional[float] = None, source: Optional[str] = None):
        self.trigger_type = trigger_type
        self.data = data
        self.timestamp = timestamp or time.time()
        self.source = source
        
    def __str__(self) -> str:
        return f"TriggerContext(type={self.trigger_type}, source={self.source}, timestamp={self.timestamp})"

class TriggerHandler:
    """Обработчик триггеров."""
    
    _instance = None
    
    def __init__(self, report_progress_func: Optional[Callable] = None):
        """
        Инициализирует обработчик триггеров.
        
        Args:
            report_progress_func: Функция для отчета о прогрессе
        """
        self.handlers = {
            TriggerType.FILE_DUPLICATION_CHECK: self._handle_file_duplication_check,}
        self.report_progress_func = report_progress_func
        self.archived_tasks_count = 0
        self.task_statistics = {}
        self.incident_statistics = {}
        
        # Регистрируем обработчики по умолчанию
        self._register_default_handlers()
        
    def _register_default_handlers(self):
        """Регистрирует обработчики по умолчанию."""
        self.register_handler(TriggerType.TASK_CREATE, self._handle_task_create)
        self.register_handler(TriggerType.TASK_UPDATE, self._handle_task_update)
        self.register_handler(TriggerType.INCIDENT_CREATE, self._handle_incident_create)
        self.register_handler(TriggerType.INCIDENT_UPDATE, self._handle_incident_update)
        self.register_handler(TriggerType.HYPOTHESIS_CREATE, self._handle_hypothesis_create)
        self.register_handler(TriggerType.HYPOTHESIS_UPDATE, self._handle_hypothesis_update)
        self.register_handler(TriggerType.STANDARD_CREATE, self._handle_standard_create)
        self.register_handler(TriggerType.STANDARD_UPDATE, self._handle_standard_update)
        self.register_handler(TriggerType.CACHE_SYNC, self._handle_cache_sync)
        self.register_handler(TriggerType.PERIODIC_CHECK, self._handle_periodic_check)
        self.register_handler(TriggerType.FILE_DUPLICATION_CHECK, self._handle_file_duplication_check)
        
    def register_handler(self, trigger_type: str, handler_func: Callable) -> bool:
        """
        Регистрирует функцию-обработчик для указанного типа триггера.
        
        Args:
            trigger_type: Тип триггера
            handler_func: Функция-обработчик
            
        Returns:
            bool: True, если регистрация успешна, иначе False
        """
        if trigger_type in self.handlers:
            logger.warning(f"Обработчик для триггера {trigger_type} уже зарегистрирован, он будет перезаписан")
            
        self.handlers[trigger_type] = handler_func
        return True
        
    def trigger(self, context: TriggerContext) -> bool:
        """
        Запускает обработку триггера.
        
        Args:
            context: Контекст триггера
            
        Returns:
            bool: True, если обработка прошла успешно, иначе False
        """
        result = self.handle_trigger(context)
        return result.success
        
    def handle_trigger(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        trigger_type = context.trigger_type
        
        if trigger_type not in self.handlers:
            logger.error(f"Неизвестный тип триггера: {trigger_type}")
            return TriggerResult(success=False, message=f"Неизвестный тип триггера: {trigger_type}")
            
        try:
            handler = self.handlers[trigger_type]
            result = handler(context)
            
            # Если обработчик вернул не TriggerResult, а что-то другое, оборачиваем в TriggerResult
            if not isinstance(result, TriggerResult):
                result = TriggerResult(success=True, message="Триггер обработан", data={"result": result})
                
            return result
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера {trigger_type}: {e}")
            traceback.print_exc()
            return TriggerResult(success=False, message=f"Ошибка при обработке триггера: {e}")
    
    def _handle_task_create(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер создания задачи.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        try:
            # Извлекаем данные из контекста
            data = context.data
            title = data.get("title", "")
            description = data.get("description", "")
            properties = data.get("properties", {})
            
            # 1. Архивация завершенных задач
            archived_count = self._archive_completed_tasks()
            logger.info(f"Архивировано {archived_count} завершенных задач")
            
            # 2. Проверка на дубликаты
            duplicates = self._check_task_duplicates(title, description)
            
            if duplicates:
                logger.warning(f"Найдены возможные дубликаты задачи '{title}': {duplicates}")
                
            # 3. Обновление статистики
            stats = self._update_task_statistics(title, properties)
            
            # 4. Отчет о прогрессе через функцию report_progress
            if self.report_progress_func:
                self.report_progress_func({
                    "event": "task_created",
                    "title": title,
                    "stats": stats,
                    "archived_count": archived_count,
                    "duplicates": duplicates,
                    "web_link": f"http://localhost:5000/tasks/view/{title.replace(' ', '_').lower()}"
                })
                
            return TriggerResult(
                success=True,
                message=f"Задача '{title}' успешно создана",
                data={
                    "title": title,
                    "stats": stats,
                    "archived_count": archived_count,
                    "duplicates": duplicates
                }
            )
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера создания задачи: {e}")
            traceback.print_exc()
            
            return TriggerResult(success=False, message=f"Ошибка при обработке триггера создания задачи: {e}")
    
    def _archive_completed_tasks(self) -> int:
        """
        Архивирует завершенные задачи.
        
        Returns:
            int: Количество архивированных задач
        """
        try:
            # Имитация архивации задач 
            # (в реальном коде здесь будет логика перемещения файлов задач из active в archive)
            self.archived_tasks_count += 1
            return self.archived_tasks_count
        except Exception as e:
            logger.error(f"Ошибка при архивации задач: {e}")
            return 0
    
    def _check_task_duplicates(self, title: str, description: str) -> list:
        """
        Проверяет наличие дубликатов задачи.
        
        Args:
            title: Название задачи
            description: Описание задачи
            
        Returns:
            list: Список возможных дубликатов
        """
        # Простая проверка на дубликаты
        duplicate_check = []
        
        # Проверяем директорию todo
        if os.path.exists("todo"):
            for root, _, files in os.walk("todo"):
                for file in files:
                    if file.endswith(".md"):
                        file_path = os.path.join(root, file)
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                content = f.read()
                                # Простая проверка на совпадение по ключевым словам
                                if title.lower() in content.lower():
                                    duplicate_check.append({"file": file_path, "similarity": "По названию"})
                        except Exception as e:
                            logger.warning(f"Ошибка при чтении файла {file_path}: {e}")
        
        return duplicate_check
    
    def _update_task_statistics(self, title: str, properties: dict) -> dict:
        """
        Обновляет статистику по задачам.
        
        Args:
            title: Название задачи
            properties: Свойства задачи
            
        Returns:
            dict: Обновленная статистика
        """
        # Обновляем статистику задач
        task_type = properties.get("task_type", "Задача")
        priority = properties.get("priority", "Средний")
        
        if task_type not in self.task_statistics:
            self.task_statistics[task_type] = {
                "total": 0,
                "priorities": {}
            }
        
        self.task_statistics[task_type]["total"] += 1
        
        if priority not in self.task_statistics[task_type]["priorities"]:
            self.task_statistics[task_type]["priorities"][priority] = 0
        
        self.task_statistics[task_type]["priorities"][priority] += 1
        
        return {
            "tasks_by_type": self.task_statistics,
            "total_tasks": sum(stats["total"] for stats in self.task_statistics.values()),
            "last_added": title
        }
    
    def _handle_task_update(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер обновления задачи.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Простая реализация
        return TriggerResult(success=True, message="Задача обновлена")
    
    def _handle_incident_create(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер создания инцидента.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        try:
            # Извлекаем данные из контекста
            data = context.data
            title = data.get("title", "")
            description = data.get("description", "")
            
            # 1. Извлечение 5-почему анализа
            five_whys = self._extract_five_whys(description)
            
            # 2. Отчет о прогрессе
            if self.report_progress_func:
                self.report_progress_func({
                    "event": "incident_created",
                    "title": title,
                    "five_whys": five_whys,
                    "web_link": f"http://localhost:5000/incidents/view/{title.replace(' ', '_').lower()}"
                })
                
            return TriggerResult(
                success=True,
                message=f"Инцидент '{title}' успешно создан",
                data={
                    "title": title,
                    "five_whys": five_whys
                }
            )
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера создания инцидента: {e}")
            traceback.print_exc()
            
            return TriggerResult(success=False, message=f"Ошибка при обработке триггера создания инцидента: {e}")
    
        def _extract_five_whys(self, description: str) -> list:
        """
        Извлекает 5-почему анализ из описания инцидента.
        
        Args:
            description: Описание инцидента
            
        Returns:
            list: Список вопросов и ответов
        """
        try:
            # Проверяем, есть ли в описании раздел 5-почему
            if "почему" not in description.lower() and "why" not in description.lower():
                logger.info("5-почему анализ не найден в описании")
                return []
            
            # Результат
            five_whys_list = []
            
            # Шаблоны для поиска
            patterns = [
                # 1. С номером и вопросительным знаком (Почему #1: ...)
                r"(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)[:\s]*([^\n?]+\?)[\s\n]*(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*|^)[\s\n]*([^\n]+)",
                
                # 2. С номером без вопросительного знака (Почему #1: ...)
                r"(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)[:\s]*([^\n]+)[\s\n]*(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*|^)[\s\n]*([^\n]+)",
                
                # 3. С номером и словом "вопрос" (Вопрос #1: ...)
                r"(?:вопрос|question)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)[:\s]*([^\n]+)[\s\n]*(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*|^)[\s\n]*([^\n]+)",
                
                # 4. С маркерами Markdown
                r"###[\s]*(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)[:\s]*([^\n]+)[\s\n]*(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*|^)[\s\n]*([^\n]+)",
                
                # 5. Общий паттерн для секции Корневая причина
                r"(?:корневая причина|root cause)[:\s]*([^\n]+)"
            ]
            
            # Проверяем каждый шаблон
            for pattern in patterns:
                matches = re.findall(pattern, description, re.IGNORECASE | re.MULTILINE)
                if matches:
                    # Если это шаблон для корневой причины
                    if "корневая причина" in pattern or "root cause" in pattern:
                        # Добавляем корневую причину в качестве отдельного элемента
                        for match in matches:
                            if isinstance(match, tuple):
                                match = match[0]  # Берем только первую группу
                            five_whys_list.append({
                                "type": "root_cause",
                                "content": match.strip()
                            })
                    else:
                        # Обрабатываем вопросы и ответы
                        for match in matches:
                            if isinstance(match, tuple) and len(match) >= 2:
                                question = match[0].strip()
                                answer = match[1].strip()
                                
                                # Добавляем вопрос и ответ к результату
                                five_whys_list.append({
                                    "type": "question_answer",
                                    "question": question,
                                    "answer": answer
                                })
            
            # Если не удалось извлечь вопросы и ответы, пробуем разбить на секции по маркерам Markdown
            if not five_whys_list:
                # Разбиваем текст на секции по маркерам Markdown
                sections = re.split(r"###+", description)
                for section in sections:
                    # Проверяем, содержит ли секция ключевые слова 5-почему
                    if re.search(r"(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)", section, re.IGNORECASE):
                        # Извлекаем заголовок секции и содержимое
                        section_match = re.match(r"([^\n]+)[\n\s]*(.*)", section.strip(), re.DOTALL)
                        if section_match:
                            title = section_match.group(1).strip()
                            content = section_match.group(2).strip()
                            
                            # Проверяем, является ли это вопросом или корневой причиной
                            if re.search(r"(?:корневая причина|root cause)", title, re.IGNORECASE):
                                five_whys_list.append({
                                    "type": "root_cause",
                                    "content": content
                                })
                            else:
                                # Ищем ответ в содержимом секции
                                answer_match = re.search(r"(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*)[\s\n]*([^\n]+)", content, re.IGNORECASE)
                                answer = answer_match.group(1).strip() if answer_match else content
                                
                                five_whys_list.append({
                                    "type": "question_answer",
                                    "question": title,
                                    "answer": answer
                                })
            
            # Если всё ещё нет результатов, ищем блоки текста, разделенные пустыми строками
            if not five_whys_list:
                # Разбиваем текст на блоки, разделенные пустыми строками
                blocks = re.split(r"\n\s*\n", description)
                for block in blocks:
                    block = block.strip()
                    if not block:
                        continue
                    
                    # Проверяем, содержит ли блок ключевые слова 5-почему
                    if re.search(r"(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)", block, re.IGNORECASE):
                        # Разбиваем блок на строки
                        lines = block.split("\n")
                        
                        # Ищем строки с вопросом и ответом
                        for i in range(len(lines) - 1):
                            if re.search(r"(?:почему|why)[\s#]*(?:\d+|один|два|три|четыре|пять|one|two|three|four|five)", lines[i], re.IGNORECASE):
                                question = lines[i].strip()
                                answer = lines[i + 1].strip()
                                
                                # Проверяем, есть ли в ответе ключевые слова
                                if not re.search(r"(?:\*\*ответ\:\*\*|ответ\:|\*\*answer\:\*\*|answer\:|\*ответ\*|\*answer\*)", answer, re.IGNORECASE):
                                    # Если нет, проверяем, есть ли в вопросе двоеточие
                                    if ":" in question:
                                        question_parts = question.split(":", 1)
                                        question = question_parts[0].strip() + "?"
                                        if len(question_parts) > 1 and question_parts[1].strip():
                                            answer = question_parts[1].strip()
                                
                                five_whys_list.append({
                                    "type": "question_answer",
                                    "question": question,
                                    "answer": answer
                                })
                    
                    # Проверяем, содержит ли блок ключевые слова корневой причины
                    elif re.search(r"(?:корневая причина|root cause)", block, re.IGNORECASE):
                        # Разбиваем блок на строки
                        lines = block.split("\n")
                        
                        # Ищем строки с корневой причиной
                        for i in range(len(lines)):
                            if re.search(r"(?:корневая причина|root cause)", lines[i], re.IGNORECASE):
                                # Если это последняя строка или следующая строка пустая, используем текущую строку
                                if i == len(lines) - 1 or not lines[i + 1].strip():
                                    # Извлекаем корневую причину из текущей строки
                                    cause_match = re.search(r"(?:корневая причина|root cause)[:\s]*([^\n]+)", lines[i], re.IGNORECASE)
                                    if cause_match:
                                        five_whys_list.append({
                                            "type": "root_cause",
                                            "content": cause_match.group(1).strip()
                                        })
                                else:
                                    # Используем следующую строку как корневую причину
                                    five_whys_list.append({
                                        "type": "root_cause",
                                        "content": lines[i + 1].strip()
                                    })
                                break
            
            logger.info(f"Найден 5-почему анализ в описании: {len(five_whys_list)} элементов")
            return five_whys_list
        except Exception as e:
            logger.error(f"Ошибка при извлечении 5-почему анализа: {e}")
            traceback.print_exc()
            return []def _handle_incident_update(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер обновления инцидента.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Простая реализация
        return TriggerResult(success=True, message="Инцидент обновлен")
    
    def _handle_hypothesis_create(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер создания гипотезы.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        try:
            # Извлекаем данные из контекста
            data = context.data
            title = data.get("title", "")
            description = data.get("description", "")
            
            # Извлекаем критерии RAT и фальсифицируемость
            rat_criteria = self._extract_rat_criteria(description)
            falsifiability = self._extract_falsifiability(description)
            
            # Отчет о прогрессе
            if self.report_progress_func:
                self.report_progress_func({
                    "event": "hypothesis_created",
                    "title": title,
                    "rat_criteria": rat_criteria,
                    "falsifiability": falsifiability,
                    "web_link": f"http://localhost:5000/hypotheses/view/{title.replace(' ', '_').lower()}"
                })
            
            return TriggerResult(
                success=True,
                message=f"Гипотеза '{title}' успешно создана",
                data={
                    "title": title,
                    "rat_criteria": rat_criteria,
                    "falsifiability": falsifiability
                }
            )
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера создания гипотезы: {e}")
            traceback.print_exc()
            
            return TriggerResult(success=False, message=f"Ошибка при обработке триггера создания гипотезы: {e}")
    
    def _extract_rat_criteria(self, description: str) -> list:
        """
        Извлекает критерии RAT из описания гипотезы.
        
        Args:
            description: Описание гипотезы
            
        Returns:
            list: Список критериев RAT
        """
        # Простая реализация
        rat_criteria = []
        
        # Ищем секцию с критериями RAT
        rat_section = re.search(r'(?i)#\s*(?:критерии|criteria|rat)\s*.*?(?=(?:#|$))', description, re.DOTALL)
        
        if rat_section:
            lines = rat_section.group(0).split('\n')
            # Пропускаем заголовок
            for line in lines[1:]:
                line = line.strip()
                if line and line.startswith(('-', '*', '•')):
                    rat_criteria.append(line.lstrip('-*• '))
        
        return rat_criteria
    
    def _extract_falsifiability(self, description: str) -> str:
        """
        Извлекает критерий фальсифицируемости из описания гипотезы.
        
        Args:
            description: Описание гипотезы
            
        Returns:
            str: Критерий фальсифицируемости
        """
        # Простая реализация
        falsifiability = ""
        
        # Ищем секцию с фальсифицируемостью
        falsifiability_section = re.search(r'(?i)#\s*(?:фальсифицируемость|falsif|опровержение)\s*.*?(?=(?:#|$))', description, re.DOTALL)
        
        if falsifiability_section:
            lines = falsifiability_section.group(0).split('\n')
            # Пропускаем заголовок
            for line in lines[1:]:
                line = line.strip()
                if line:
                    falsifiability += line + " "
        
        return falsifiability.strip()
    
    def _handle_hypothesis_update(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер обновления гипотезы.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Простая реализация
        return TriggerResult(success=True, message="Гипотеза обновлена")
    
    def _handle_standard_create(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер создания стандарта.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        try:
            # Извлекаем данные из контекста
            data = context.data
            title = data.get("title", "")
            content = data.get("content", "")
            
            # Проверка на близкие стандарты
            similar_standards = self._check_similar_standards(title, content)
            
            # Отчет о прогрессе
            if self.report_progress_func:
                self.report_progress_func({
                    "event": "standard_created",
                    "title": title,
                    "similar_standards": similar_standards,
                    "web_link": f"http://localhost:5000/standards/view/{title.replace(' ', '_').lower()}"
                })
            
            return TriggerResult(
                success=True,
                message=f"Стандарт '{title}' успешно создан",
                data={
                    "title": title,
                    "similar_standards": similar_standards
                }
            )
        except Exception as e:
            logger.error(f"Ошибка при обработке триггера создания стандарта: {e}")
            traceback.print_exc()
            
            return TriggerResult(success=False, message=f"Ошибка при обработке триггера создания стандарта: {e}")
    
    def _check_similar_standards(self, title: str, content: str) -> list:
        """
        Проверяет наличие похожих стандартов.
        
        Args:
            title: Название стандарта
            content: Содержимое стандарта
            
        Returns:
            list: Список похожих стандартов
        """
        # Простая реализация
        similar_standards = []
        
        # Проверяем директорию standards
        if os.path.exists("standards"):
            for root, _, files in os.walk("standards"):
                for file in files:
                    if file.endswith(".md"):
                        file_path = os.path.join(root, file)
                        try:
                            with open(file_path, 'r', encoding='utf-8') as f:
                                standard_content = f.read()
                                
                                # Простая проверка на совпадение по заголовку
                                if title.lower() in standard_content.lower():
                                    similar_standards.append({
                                        "path": file_path,
                                        "reason": "Совпадение по заголовку"
                                    })
                        except Exception as e:
                            logger.warning(f"Ошибка при чтении файла {file_path}: {e}")
        
        return similar_standards
    
    def _handle_standard_update(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер обновления стандарта.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Простая реализация
        return TriggerResult(success=True, message="Стандарт обновлен")
    
    def _handle_cache_sync(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер синхронизации кеша.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Простая реализация
        return TriggerResult(success=True, message="Кеш синхронизирован")
    
    def _handle_file_duplication_check(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер проверки дублирования файлов.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        try:
            # Извлекаем данные из контекста
            data = context.data
            file_paths = data.get("file_paths", [])
            
            if not file_paths:
                return TriggerResult(
                    success=False,
                    message="Не указаны пути к файлам для проверки дублирования"
                )
            
            # Простая проверка дублирования кода
            duplications = self._find_code_duplications(file_paths)
            
            # Отчет о прогрессе
            if self.report_progress_func and duplications:
                self.report_progress_func({
                    "event": "file_duplication_check",
                    "duplications": duplications,
                    "message": f"Найдено {len(duplications)} дублирований кода"
                })
            
            return TriggerResult(
                success=True,
                message=f"Проверка дублирования файлов завершена, проверено {len(file_paths)} файлов",
                data={"duplications": duplications}
            )
        except Exception as e:
            logger.error(f"Ошибка при проверке дублирования файлов: {e}")
            traceback.print_exc()
            return TriggerResult(success=False, message=f"Ошибка при проверке дублирования файлов: {e}")
    
    def _find_code_duplications(self, file_paths: list) -> list:
        """
        Находит дублирования кода в файлах.
        
        Args:
            file_paths: Список путей к файлам для проверки
            
        Returns:
            list: Список найденных дублирований
        """
        # Простая реализация
        duplications = []
        
        # Создаем хеш-карту для хранения хешей блоков кода
        code_blocks = {}
        
        for path in file_paths:
            if not path.endswith('.py'):
                continue
                
            try:
                with open(path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    
                    # Разбиваем содержимое на блоки по 5 строк
                    lines = content.split('\n')
                    for i in range(len(lines) - 4):
                        block = '\n'.join(lines[i:i+5])
                        
                        # Игнорируем пустые блоки и комментарии
                        if not block.strip() or block.strip().startswith('#'):
                            continue
                            
                        # Вычисляем хеш блока
                        block_hash = hashlib.md5(block.encode()).hexdigest()
                        
                        if block_hash in code_blocks:
                            # Найдено дублирование
                            duplications.append({
                                'file1': code_blocks[block_hash]['file'],
                                'line1': code_blocks[block_hash]['line'],
                                'file2': path,
                                'line2': i + 1,
                                'content': block
                            })
                        else:
                            code_blocks[block_hash] = {
                                'file': path,
                                'line': i + 1
                            }
            except Exception as e:
                logger.warning(f"Ошибка при чтении файла {path}: {e}")
        
        return duplications
    
    def _handle_periodic_check(self, context: TriggerContext) -> TriggerResult:
        """
        Обрабатывает триггер периодической проверки.
        
        Args:
            context: Контекст триггера
            
        Returns:
            TriggerResult: Результат обработки триггера
        """
        # Простая реализация
        return TriggerResult(success=True, message="Периодическая проверка выполнена")


# Функция для получения экземпляра обработчика триггеров (синглтон)
def get_handler(report_progress_func: Optional[Callable] = None) -> TriggerHandler:
    """
    Возвращает экземпляр обработчика триггеров (синглтон).
    
    Args:
        report_progress_func: Функция для отчета о прогрессе
        
    Returns:
        TriggerHandler: Экземпляр обработчика триггеров
    """
    if TriggerHandler._instance is None:
        TriggerHandler._instance = TriggerHandler(report_progress_func)
    return TriggerHandler._instance

# Функция для совместимости с предыдущими версиями
def get_trigger_handler_instance(report_progress_func: Optional[Callable] = None) -> TriggerHandler:
    """
    Возвращает экземпляр обработчика триггеров для совместимости.
    Обертка вокруг функции get_handler.
    
    Args:
        report_progress_func: Функция для отчета о прогрессе
        
    Returns:
        TriggerHandler: Экземпляр обработчика триггеров
    """
    return get_handler(report_progress_func)